<!DOCTYPE html><html lang="[&quot;en&quot;,&quot;zh-CN&quot;,&quot;default&quot;]"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="Npc"><meta name="copyright" content="Npc"><meta name="generator" content="Hexo 7.1.1"><meta name="theme" content="hexo-theme-yun"><title>初识Windows内核 | Npc | Blog</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.4.1/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/my_blog_prism@1.0.5/prism.css"><script src="https://cdn.jsdelivr.net/npm/my_blog_prism@1.0.5/prism.js"></script><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"npc0vo.github.io","root":"/","title":"Npc小站","version":"1.10.11","mode":"light","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"local_search":{"path":"/search.xml"},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"fireworks":{"colors":null},"waline":{"config":{"enable":true,"serverURL":"https://waline-onelastchicks-projects.vercel.app/","comment":false,"el":"#waline","lang":["en","zh-CN","default"]},"cdn":"https://fastly.jsdelivr.net/npm/@waline/client@v2/dist/waline.js","dark":"html.dark"},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=G-1LL0D86CY9"></script><script>if (CONFIG.hostname === location.hostname) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-1LL0D86CY9');
}</script><script data-ad-client="ca-pub-2245427233262012" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><!-- Google Tag Manager --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-M9KWR9L');</script><!-- End Google Tag Manager --><meta name="description" content="前言 学习Windows内核的基础(感觉真的好复杂) 基于&lt;&lt;加密与解密&gt;&gt;Chap7以及网上的多个blog  理论基础  权限级别 CPU设计者将CPU的运行级别从内到外分为4个，R0,R1,R2,R3，权限依次降低 设计之初是想让R0运行内核,R1,R2运行设备驱动，R3运行应用程序 但是为了工作简单，并没有使用R1,R2，而是将设备驱动运行在内核同一级别的R0  分">
<meta property="og:type" content="article">
<meta property="og:title" content="初识Windows内核">
<meta property="og:url" content="http://npc0vo.github.io/2024/07/09/%E5%88%9D%E8%AF%86Windows%E5%86%85%E6%A0%B8/index.html">
<meta property="og:site_name" content="Npc | Blog">
<meta property="og:description" content="前言 学习Windows内核的基础(感觉真的好复杂) 基于&lt;&lt;加密与解密&gt;&gt;Chap7以及网上的多个blog  理论基础  权限级别 CPU设计者将CPU的运行级别从内到外分为4个，R0,R1,R2,R3，权限依次降低 设计之初是想让R0运行内核,R1,R2运行设备驱动，R3运行应用程序 但是为了工作简单，并没有使用R1,R2，而是将设备驱动运行在内核同一级别的R0  分">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://npc0vo.github.io/2024/07/09/%E5%88%9D%E8%AF%86Windows%E5%86%85%E6%A0%B8/image-20240709191150034.png">
<meta property="og:image" content="http://npc0vo.github.io/2024/07/09/%E5%88%9D%E8%AF%86Windows%E5%86%85%E6%A0%B8/92f99911b133ef40f635537c49ffac56.png">
<meta property="og:image" content="http://npc0vo.github.io/2024/07/09/%E5%88%9D%E8%AF%86Windows%E5%86%85%E6%A0%B8/image-20240709192706570.png">
<meta property="og:image" content="http://npc0vo.github.io/2024/07/09/%E5%88%9D%E8%AF%86Windows%E5%86%85%E6%A0%B8/image-20240709193043416.png">
<meta property="og:image" content="http://npc0vo.github.io/2024/07/09/%E5%88%9D%E8%AF%86Windows%E5%86%85%E6%A0%B8/image-20240709210240690.png">
<meta property="og:image" content="http://npc0vo.github.io/2024/07/09/%E5%88%9D%E8%AF%86Windows%E5%86%85%E6%A0%B8/image-20240709200200766.png">
<meta property="og:image" content="http://npc0vo.github.io/2024/07/09/%E5%88%9D%E8%AF%86Windows%E5%86%85%E6%A0%B8/image-20240709201115793.png">
<meta property="og:image" content="http://npc0vo.github.io/2024/07/09/%E5%88%9D%E8%AF%86Windows%E5%86%85%E6%A0%B8/a19524539f608cdeb3ead544362246b6.png">
<meta property="og:image" content="http://npc0vo.github.io/2024/07/09/%E5%88%9D%E8%AF%86Windows%E5%86%85%E6%A0%B8/8390afe0659d26fa73af7df95095e051.png">
<meta property="og:image" content="http://npc0vo.github.io/2024/07/09/%E5%88%9D%E8%AF%86Windows%E5%86%85%E6%A0%B8/20cb006fd5e9455bee6c3565a200ec2b.png">
<meta property="og:image" content="http://npc0vo.github.io/2024/07/09/%E5%88%9D%E8%AF%86Windows%E5%86%85%E6%A0%B8/bd58d8151f6e2f62337694a1f12a2df4.png">
<meta property="article:published_time" content="2024-07-09T11:08:11.000Z">
<meta property="article:modified_time" content="2024-07-09T14:57:59.733Z">
<meta property="article:author" content="Npc">
<meta property="article:tag" content="Reverse">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://npc0vo.github.io/2024/07/09/%E5%88%9D%E8%AF%86Windows%E5%86%85%E6%A0%B8/image-20240709191150034.png"><script>(function() {
  if (CONFIG.mode !== 'auto') return
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="Npc"><img width="96" loading="lazy" src="/images/avatar.jpg" alt="Npc"><span class="site-author-status">😭</span></a><div class="site-author-name"><a href="/about/">Npc</a></div><span class="site-name">Npc | Blog</span><sub class="site-subtitle">想s</sub><div class="site-description"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">68</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">10</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">14</span></a></div><a class="site-state-item hty-icon-button" href="/about/#comment" title="留言板"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:clipboard-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/npc0vo" title="GitHub" target="_blank" style="color:#6e5494"><span class="icon iconify" data-icon="ri:github-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:me@1930278836@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><span class="icon iconify" data-icon="ri:mail-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.yuque.com/npc0vo" title="Yuque" target="_blank" style="color:#0088CC"><span class="icon iconify" data-icon="ri:twitter-line"></span></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:genderless-line"></span></a></div></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text"> 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text"> 理论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E7%BA%A7%E5%88%AB"><span class="toc-number">2.1.</span> <span class="toc-text"> 权限级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80"><span class="toc-number">2.2.</span> <span class="toc-text"> 内存空间布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#windows%E4%B8%8E%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text"> Windows与内核启动过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#r3%E4%B8%8Er0%E9%80%9A%E4%BF%A1"><span class="toc-number">2.4.</span> <span class="toc-text"> R3与R0通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#windows%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84"><span class="toc-number">2.5.</span> <span class="toc-text"> Windows内核结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%8A%BD%E8%B1%A1%E5%B1%82hal"><span class="toc-number">2.5.1.</span> <span class="toc-text"> 硬件抽象层HAL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%B1%82"><span class="toc-number">2.5.2.</span> <span class="toc-text"> 内核层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%BD%93%E5%B1%82"><span class="toc-number">2.5.3.</span> <span class="toc-text"> 执行体层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.5.4.</span> <span class="toc-text"> 设备驱动程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">2.5.5.</span> <span class="toc-text"> 文件系统&#x2F;存储管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C"><span class="toc-number">2.5.6.</span> <span class="toc-text"> 网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#windows%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.5.7.</span> <span class="toc-text"> Windows子系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86"><span class="toc-number">2.5.8.</span> <span class="toc-text"> 窗口管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.5.9.</span> <span class="toc-text"> 图形设备接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.5.10.</span> <span class="toc-text"> 系统线程和系统进程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.6.</span> <span class="toc-text"> 内核基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.6.1.</span> <span class="toc-text"> 处理器模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">2.6.2.</span> <span class="toc-text"> 内存管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">2.6.3.</span> <span class="toc-text"> 分页机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">2.6.4.</span> <span class="toc-text"> 进程和线程管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-number">2.6.5.</span> <span class="toc-text"> 中断和异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5"><span class="toc-number">2.6.6.</span> <span class="toc-text"> 同步</span></a></li></ol></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="http://npc0vo.github.io/2024/07/09/%E5%88%9D%E8%AF%86Windows%E5%86%85%E6%A0%B8/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Npc"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Npc | Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">初识Windows内核</h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="Created: 2024-07-09 19:08:11" itemprop="dateCreated datePublished" datetime="2024-07-09T19:08:11+08:00">2024-07-09</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="Word count in article"><span class="icon iconify" data-icon="ri:file-word-line"></span></span> <span title="Word count in article">12.5k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="Reading time"><span class="icon iconify" data-icon="ri:timer-line"></span></span> <span title="Reading time">43m</span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><span class="icon iconify" data-icon="ri:folder-line"></span></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/Reverse/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">Reverse</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/Reverse/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">Reverse</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>学习Windows内核的基础(感觉真的好复杂)</p>
<p>基于<code>&lt;&lt;加密与解密&gt;&gt;</code>Chap7以及网上的多个blog</p>
<h2 id="理论基础"><a class="markdownIt-Anchor" href="#理论基础"></a> 理论基础</h2>
<h3 id="权限级别"><a class="markdownIt-Anchor" href="#权限级别"></a> 权限级别</h3>
<p>CPU设计者将CPU的运行级别从内到外分为4个，R0,R1,R2,R3，权限依次降低</p>
<p>设计之初是想让R0运行内核,R1,R2运行设备驱动，R3运行应用程序</p>
<p>但是为了工作简单，并没有使用R1,R2，而是将设备驱动运行在内核同一级别的R0</p>
<img src="/2024/07/09/%E5%88%9D%E8%AF%86Windows%E5%86%85%E6%A0%B8/image-20240709191150034.png" class="" alt="image-20240709191150034" loading="lazy">
<p>分级的<strong>目的</strong>是为了<strong>保护系统的稳定性和安全性</strong>。通过限制某些操作只能在高权限级别下执行，操作系统可以防止用户级应用程序意外或恶意地修改关键系统资源，进而导致系统崩溃或安全漏洞。</p>
<img src="/2024/07/09/%E5%88%9D%E8%AF%86Windows%E5%86%85%E6%A0%B8/92f99911b133ef40f635537c49ffac56.png" class="" alt="image-20231226163845412" loading="lazy">
<ul>
<li>Ring0 内核模式<code>HAL</code>是一个可加载的核心模块<code>HAL.DLL</code>，它为运行在<code>WindowsXP</code>上的硬件平台提供低级接口.WINDOWSXP的执行体是<code>NTOSKRNL.EXE</code>的上层，内核是其下层。用户层导出并且可以调用的函数接口在<code>NTDLL.DLL</code>中，通过使用<code>Win32API</code>或其他环境子系统对它们进行访问</li>
<li>Ring3 用户模式 程序的代码<strong>只能</strong>运行在用户模式下，每当它需要使用到系统内核或内核的扩展模块（内核驱动程序）所提供的服务时，应用程序通过<strong>硬件指令</strong>从用户模式切换到内核模式中；当系统内核完成了所请求的服务以后，控制权又回到用户模式代码。</li>
</ul>
<h3 id="内存空间布局"><a class="markdownIt-Anchor" href="#内存空间布局"></a> 内存空间布局</h3>
<p>Windows中，用户代码和内核代码有各自的运行环境，并且它们可以访问的内存空间也不同。</p>
<p>以x86为例，支持32位寻址，因此支持4GB虚拟内存空间(可以通过PAE技术，增加到36位寻址将寻址空间扩大到64GB)</p>
<img src="/2024/07/09/%E5%88%9D%E8%AF%86Windows%E5%86%85%E6%A0%B8/image-20240709192706570.png" class="" alt="image-20240709192706570" loading="lazy">
<p>如图，在4GB的虚拟地址空间中，<code>Windows</code>系统的内存主要分为内核空间和应用层空间，各占约2GB，其中还包括64KB的NULL空间和非法区域</p>
<p>Windows内存的逻辑地址分为两部分:<code>段选择符</code>和<code>偏移地址</code></p>
<p><mark>CPU进行地址翻译的时候，先通过分页机制计算出一个线性地址，再通过页表机制将线性地址映射到物理地址，从而存取物理内存中的数据和指令</mark></p>
<img src="/2024/07/09/%E5%88%9D%E8%AF%86Windows%E5%86%85%E6%A0%B8/image-20240709193043416.png" class="" alt="image-20240709193043416" loading="lazy">
<p>x64与x86类似，但是x64的寻址空间太大了，会存在很多空洞，有很多空间并不可用</p>
<h3 id="windows与内核启动过程"><a class="markdownIt-Anchor" href="#windows与内核启动过程"></a> Windows与内核启动过程</h3>
<ol>
<li>
<p>启动自检阶段</p>
<p>打开电源，开始自检，从BIOS载入必要指令，进行硬件的初始化检查</p>
</li>
<li>
<p>初始化启动阶段</p>
<p>自检完成，根据CMOS的设置，BIOS加载启动盘，将主引导记录(MBR)中的引导代码载入内存，接着，启动过程由MBR来执行</p>
<p>启动代码会搜索MBR中的分区表，找出活动分区，将第一个扇区中的引导代码载入内存。引导代码检测当前使用的文件系统，查找<code>ntldr</code>文件</p>
<p>找到后启动该文件</p>
<p><code>BIOS</code>将控制权转交给<code>NTLDR</code> ，<code>NTLDR</code>完成操作系统的启动工作,<code>Windows7</code>使用的是<code>bootmgr</code></p>
</li>
<li>
<p>Boot加载</p>
<p>先从启动分区加载<code>ntldr</code>，然后对<code>ntldr</code>进行如下设置</p>
<ol>
<li>设置内存模式（如果是x86处理器，且是32位系统)设置为<code>32-bit flat memory</code></li>
<li>启动一个简单的文件系统，以定位<code>boot.ini ntoskrnl Hal</code>等启动文件</li>
<li>读取<code>boot.ini</code></li>
</ol>
</li>
<li>
<p>检测和配置硬件阶段</p>
<p>这个阶段会检查和配置硬件设备</p>
</li>
<li>
<p>内核加载过程</p>
<ol>
<li>
<p><code>NTLDR</code>首先加载<code>Windows</code>内核<code>Ntoskrnl.exe</code>和硬件抽象层<code>HAL</code></p>
</li>
<li>
<p><code>HAL</code>会对硬件底层的特性进行隔离，然后为操作系统提供统一的调用接口</p>
</li>
<li>
<p><code>ntldr</code>从注册表<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet</code>键下读取这台机器安装的驱动程序，然后依次加载驱动程序，初始化底层设备驱动，在注册表的<code>HEKY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services</code>键下查找<code>Start</code>键的值为0和1的设备驱动</p>
<p>其中<code>Start</code>值可以为0,1,2,3,4 数值越小，启动越早</p>
<p><code>SERVICE_BOOT_START(0)</code>表示内核刚刚初始化，此时加载的都是与系统核心有关的重要驱动程序，如磁盘驱动</p>
<p><code>SERVICE_BOOT_START(1)</code>晚一点，稍微不那么重要的驱动程序</p>
<p><code>SERVICE_AUTO_START(2)</code>是从登录界面出现的时候开始加载,如果登录速度比较快，很可能驱动还没加载就已经登录了</p>
<p><code>SERVICE_DEMAND_START(3)</code>表示在需要的时候手动加载</p>
<p><code>SERVICE_DISABLED(4)</code>来表示禁止加载</p>
</li>
</ol>
</li>
<li>
<p>Windows的会话管理启动</p>
<p>驱动程序加载完成，内核会启动会话管理器。这是一个名为<code>smss.exe</code>的程序,在<code>Windows</code>中第一个创建的用户模式进程，起作用如下</p>
<ol>
<li>创建系统环境变量</li>
<li>加载<code>win32k.sys</code>，这是<code>Windows</code>子系统的内核模式部分</li>
<li>启动<code>csrss.exe</code>，(Client/server Runtime SubSystem)这是<code>Windows</code>子系统的用户模式部分</li>
<li>启动<code>winlogon.exe</code>,管理用户登录和注销，验证用户的登录凭据，并且初始化图形用户界面</li>
</ol>
</li>
<li>
<p>Windows登录阶段</p>
<p><code>Windows</code>子系统启动的<code>winlogon.exe</code>系统服务提供对<code>Windows</code>用户的登录和注销的支持，可以完成以下的注册工作</p>
<ol>
<li>启动服务器子系统(Services.exe)，也称服务控制管理器(SCM)</li>
<li>启动本地安全授权(LSA)过程(lsass.exe)</li>
<li>显示登录界面</li>
</ol>
<p>登录组件将用户的账号和密码安全地传送到<code>LSA</code>进行认证处理。如果用户提供的信息正确就能通过认证允许对系统的访问</p>
</li>
<li>
<p>Windows7 与 windowsxp启动过程的区别</p>
<ul>
<li><code>BIOS</code>通过自检后，将MBR载入内存并执行，引导代码会找到启动管理器<code>Bootmgr</code></li>
<li><code>bootmgr</code>寻找活动分区<code>boot</code>文件夹中的启动配置数据<code>BCD</code>文件，读取并组成相应语言的启动菜单，在屏幕显示多操作系统选择画面</li>
<li><code>bootmgr</code>读取系统文件<code>windows\system32\winload.exe</code>并将控制权交给<code>winload.exe</code></li>
<li>然后<code>winload.exe</code>加载<code>win7</code>的内核，然后过程与xp类似</li>
<li><code>xp</code>的启动过程在<code>2024</code>已经淘汰。。。</li>
</ul>
</li>
<li>
<p>系统引导方式<code>UEFI</code>与<code>GPT</code></p>
<p><code>UEFI</code>j结合<code>GPT</code>会成为今后系统引导的主要解决方案</p>
<ul>
<li>UEF[(统一可扩展Finnware接口，统一的可扩展固件接口)的出现主要用于替换BIOS.在UEFT中，用于表示lba的地址是64位的，突破了在BIOS与mbr技术方案中分区容量2TB的限制.UEFI本身已经相当于一个微型操作系统了.UEFI具备文件系统的支持能力，能够直接读取FAT分区中的文件.开发人员可以开发出直接在UEFI下运行的应用程序，这类程序文件通常以“EFI”结尾.我们可以将安装程序做成en类型的应用程序，然后把它放到任意分区中直接运行这使安装操作系统变得简单.而在UEFI下，这些统统都不需要–不需要主引导记录不需要活动分区，不需要任何工具.只要将安装文件复制到一个FAT 32(主)分区或U盘中，通过)这个分区或U盘即可安装和启动窗口</li>
<li>与传统的MBR分区表相比，新型的GPT(GUID划分表，全局唯一标识分区表)对分区)数量没有限制，但在实现gpt的时候，将分区个数限制在128个cpt分区以内，gpt可管<br />
理磁盘大小达到了18EB，因此，只有基于UEFI平台的主板才支持GPT分区引导启动.</li>
</ul>
</li>
</ol>
<h3 id="r3与r0通信"><a class="markdownIt-Anchor" href="#r3与r0通信"></a> R3与R0通信</h3>
<img src="/2024/07/09/%E5%88%9D%E8%AF%86Windows%E5%86%85%E6%A0%B8/image-20240709210240690.png" class="" alt="image-20240709210240690" loading="lazy">
<p>例如应用程序调用了一个有关I/O的api</p>
<p>这个API实际上被封装在应用层的某个<code>DLL动态库</code>(kernel.dll,user32.dll)，而<code>DLL动态库</code>中的函数更底层包含在<code>ntdll.dll</code>文件中</p>
<p>当<code>kernel32.dll</code>中的API通过<code>ntdll.dll</code>执行时，会完成参数的检查工作，再调用一个中断(int 2Eh,或者SysEnter指令)，从R3进入R0</p>
<p>在内核<code>ntoskrnl</code>(NT operating system kernel)有一个SSDT，里面存放了与<code>ntdll.dll</code>中对应的SSDT系统服务处理函数，即内核态的NT*系列函数，</p>
<ol>
<li>
<p>从用户模式调用<code>NT*</code>和<code>Zw*</code>API,连接<code>ntdll.lib</code></p>
<p>都是通过设置系统服务器表中的索引和在栈中设置参数。通过syscall指令进入内核态。然后跳转到<code>KiSystemService</code>跳转到对应的系统服务器例程。由于是用户模式进入内核模式，代码会严格检查用户空间传入的参数</p>
</li>
<li>
<p>从内核模式调用<code>NT*</code>和<code>Zw*</code>API，连接<code>ntoskrnl.lib</code></p>
<p><code>NT*</code>系统API将直接调用对应的函数代码</p>
<p><code>Zw*</code>系统API则通过<code>kiSystemService</code>最终跳转到对应的函数代码处。</p>
<p>这两种调用对内核中<code>PreviousMode</code>进行,如果是从内核模式调用<code>NativeAPI</code>则<code>PM</code>是用户态;如果从内核模式，则<code>PM</code>是内核态</p>
<p>当<code>PM</code>是用户态``NativeAPI`会严格检查参数</p>
<p>当<code>PM</code>是内核态<code>NativeAPI</code>不会检查参数</p>
<p>在调用用户模式<code>NT*API</code>不会改变<code>PM</code></p>
<p>调用<code>Zw*API</code>会将PM改为内核态</p>
<p>因此在<code>KernelModeDriver</code>尽量使用<code>Zw*API</code>可以提高效率</p>
</li>
</ol>
<p>内核主要由各种驱动(在磁盘上是.sys文件)组成，这些驱动有的是 Windows系统自带的(例如 ntfs.sys、tepip.sys、wn32k.sys)，有的是由第三方软件厂商提供的。驱动加载之后，会生成对应的设<br />
备对象，并可以选择向 R3提供一个可供访问和打开的符号链接。常见的盘符C、D、E等其实都是文件系统驱动创建的设备对象的符号链接，对应的符号链接名<br />
应用层程序可以根据内核驱动的符号链接名调用CreateFile0函数打开。在获得一个句柄(Handle)之后，程序就可以调用应用层函数与内核驱动进行通信了，例如ReadFile0)、WriteFile0)及DeviceloControl()等。<br />
内核驱动一旦执行了 DriverEntry入口函数,就可以接收 R3层的通信请求了。在内核驱动中专门有一组分发派遣函数用来分别响应应用层的调用请求</p>
<h3 id="windows内核结构"><a class="markdownIt-Anchor" href="#windows内核结构"></a> Windows内核结构</h3>
<img src="/2024/07/09/%E5%88%9D%E8%AF%86Windows%E5%86%85%E6%A0%B8/image-20240709200200766.png" class="" alt="image-20240709200200766" loading="lazy">
<p>Windows内核中主要可以分成三层：<strong>硬件抽象层</strong>（HAL），<strong>内核层</strong>（也称微内核micro-kernel），<strong>执行体层</strong>。</p>
<p>内核层实现操作系统的基本机制，而所有的策略决定则留给执行体。执行体中的对象绝大多数封装了一个或者多个内核对象，并且通过某种方式（比如对象句柄）暴露给应用程序。</p>
<p>Windows内核为用户模式提供了一组<strong>系统服务</strong>，供应用程序使用内核中的功能。应用程序通常并不直接调用这些系统服务，而是通过一组系统DLL，最终通过<strong>ntdll.dll</strong>切换到内核模式下的执行体API函数中，以调用内核中的系统服务。</p>
<p><em>Ntdll.dll是链接用户模式代码和内核模式系统服务的桥梁。对于内核提供的每一个系统服务，该DLL都提供一个相应的存根函数，这些存根函数的名称以“Nt”作为前缀，例如NtCreateProcess、NtOpenFile等。另外ntdll.dll还提供了许多系统级的支持函数，比如映像加载器函数（以“Ldr”为前缀）、系统时间函数（以“Etw”为前缀），以及一般的运行支持函数（以“Rtl”为前缀）和字符串支持函数等。</em><br />
执行体API函数接收的参数来自于各种应用程序，因此为了保证系统的安全以及抵抗来自用户模式的恶意攻击，所有的执行体API都必须保证参数的<strong>有效性</strong>。通常执行体系统服务函数会在其开始处，对所接收的参数逐一探查它们的可访问性。</p>
<p>例如</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">PreviousMode <span class="token operator">=</span> <span class="token function">KeGetPreviousMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取当前的执行模式，内核模式or用户模式</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>PreviousMode <span class="token operator">!=</span> kernelMode<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//如果是用户模式</span>
    <span class="token keyword">try</span><span class="token punctuation">&#123;</span>
        <span class="token function">ProbeForWrite</span><span class="token punctuation">(</span>InputInformation<span class="token punctuation">,</span>InputInformationLength<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ULONG<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//检查内存可写性，检查inputinformation指向的内存区域是否可以安全写入数据,第二三个参数分别是数据的长度和数据大小</span>
        <span class="token comment">//接着检查是否传递了ReturnLength参数，如果传递了就进一步检查内存可谢谢</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ARGUMENT_PRESENT</span><span class="token punctuation">(</span>ReturnLength<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token function">ProbeForWriteUlong</span><span class="token punctuation">(</span>ReturnLength<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token function">except</span><span class="token punctuation">(</span>EXCEPTION_EXECUTE_HANDLER<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token function">GetExceptionCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取错误码</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="硬件抽象层hal"><a class="markdownIt-Anchor" href="#硬件抽象层hal"></a> 硬件抽象层HAL</h4>
<p><strong>硬件抽象层（Hardware Abstraction Layer，HAL）</strong>，这一层把所有与硬件相关联的代码逻辑隔离到一个专门的模块中，为操作系统的上层提供一个<strong>抽象</strong>的、一致的硬件资源模型。这使得上层的模块无须考虑硬件的差异，它们通过HAL而不是直接访问硬件。</p>
<p>在Windows中，<strong>HAL是一个独立的动态链接库</strong>。HAL提供了一些例程供其他内核模块或设备驱动程序调用，这使得一个驱动程序可以支持同样的设备在各种硬件平台上运行。HAL不仅涵盖了处理器的体系结构，也涉及了中断控制器、单处理器或多处理器等硬件条件。</p>
<h4 id="内核层"><a class="markdownIt-Anchor" href="#内核层"></a> 内核层</h4>
<p>这是大内核中的小内核，也称<strong>微内核</strong>。它是<strong>内核模块ntoskrnl.exe</strong>的<strong>下层</strong>部分(上层为执行体),最接近HAL层,负责<strong>线程调度</strong>和<strong>中断、异常的处理</strong>。对于多处理器系统，它还负责同步处理器之间的行为，以优化系统的性能。</p>
<p>Windows的内核实现了抢占式线程调度机制，按照优先级顺序将线程分配到处理器上，并且允许高优先级的线程中断或抢占低优先级的线程。每个线程有一个基本优先级值（base priority）和一个动态优先级值。根据这俩个值，内核根据调度规则来切换线程，让系统更快响应用户的动作，以及在系统服务和其他低优先级进程之间平衡处理器资源的分配。</p>
<p>Windows内核按照面向对象的思想来设计，它管理俩种类型的对象：分发器对象和控制对象。分发器对象实现了各种同步功能，这些对象的状态会影响线程的调度。Windows内核实现的分发器对象包括事件（event）、突变体（mutant）、信号量（semaphore）、进程（process）、线程（thread）、队列（queue）、门（gate）和定时器（timer）。控制对象被用于控制内核的操作但是不影响线程的调度，它包括异步过程调用（APC）、延迟过程调用（DPC），以及中断对象等。</p>
<h4 id="执行体层"><a class="markdownIt-Anchor" href="#执行体层"></a> 执行体层</h4>
<p>执行体是内核模块ntoskrnl.exe的上层部分，它包含5种类型的函数：</p>
<ul>
<li><strong>系统服务调度函数（System Service Dispatch Functions）</strong>：这些函数主要负责响应系统服务请求。当用户模式应用程序请求操作系统服务时，这些函数会被调用。例如NtCreateFile、NtReadFile等函数。</li>
<li><strong>内核模式支持函数（Kernel Mode Support Functions）</strong>：这类函数提供给其他内核模式组件使用，以执行各种底层任务，如内存管理、进程和线程管理等。例如ExAlloctePool：分配内核池内存、KeSetEvent：设置一个事件对象的状。</li>
<li><strong>执行对象管理函数（Executive Object Management Functions）</strong>：这些函数用于管理Windows中的各种执行对象，如进程、线程、事件、信号量等。例如 ObOpenObjectByPointer :根据对象指针打开对象、 ExCreateCallback：创建一个回调对象。</li>
<li><strong>安全引用监视器函数（Security Reference Monitor Functions）</strong>：这些函数用于实现操作系统的安全机制，包括访问控制、权限检查等。例如 SeAccessCheck：检查访问权限。</li>
<li><strong>I/O系统支持函数（I/O System Support Functions）</strong>：这些函数支持输入/输出系统的操作，包括文件系统的管理、设备驱动程序的交互等。例如 IoWriteErrorLogEntry：写入错误日志条目。</li>
</ul>
<img src="/2024/07/09/%E5%88%9D%E8%AF%86Windows%E5%86%85%E6%A0%B8/image-20240709201115793.png" class="" alt="image-20240709201115793" loading="lazy">
<p>与应用层函数不同，在windows操作系统中调用内核函数必须要关注<strong>中断请求级别（IRQL，Interrupt Request Level）</strong>。</p>
<p>IRQL 是一个表示<strong>中断优先级</strong>的数字，用于确保处理器在处理不同的任务时维持正确的操作顺序和安全性。操作系统内核使用不同的 IRQL 来管理对硬件资源的访问，以及处理不同级别的中断和异常。</p>
<p>在调用内核函数时，必须要确保当前的IRQL与被调用函数所要求的级别<strong>相符</strong>。不遵守这一规则可能导致系统崩溃或数据损坏。IRQL的级别如下：</p>
<ol>
<li>被动级别（PASSIVE_LEVEL）：这是最低的IRQL级别。在此级别，线程可以被抢占，可以执行任何类型的内核模式代码，包括页面操作。</li>
<li>APC级别（APC_LEVEL）：此级别用于阻止异步过程调用（APC）的执行。<br />
调度级别（DISPATCH_LEVEL）：在此级别，可以阻止线程调度，但仍允</li>
<li>处理硬件中断。很多非分页内存操作需要在此级别或更低级别执行</li>
<li>DIRQL（设备IRQL）：这是特定于设备的中断级别。不同的设备驱动程序可能会使用不同的DIRQL。</li>
<li>高IRQL（HIGH_LEVEL）：这是最高的IRQL级别，用于系统关键操作，此时几乎所有的中断都被禁止。</li>
</ol>
<p>开发内核模式驱动程序时，合理地管理IRQL至关重要。如果一个函数要求在低IRQL下运行，而当前IRQL较高，就不能直接调用那个函数；反之亦然。不正确的IRQL处理可能导致系统不稳定或蓝屏（BSOD）。</p>
<p>执行体中除了函数组成，还有以下多个重要的组件</p>
<ul>
<li>内存管理器：实现了虚拟内存管理，既负责系统地址空间的内存管理，又为每个进程提供了一个私有的地址空间，支持进程之间的内存共享。内存管理器也为缓存管理器提供了底层支持。</li>
<li>缓存管理器：它为文件系统提供了统一的数据缓存支持，允许文件系统驱动程序将磁盘上的数据映射到内存中，并通过内存管理器来协调物理内存的分配。</li>
<li>文件系统：管理文件和目录的创建、读写和组织。</li>
<li>进程和线程管理器：负责进程线程的创建和终止。在Windows中，对于进程和线程的底层支持是在内核层提供的，执行体只是在其基础上提供了一些语义和功能。</li>
<li>即插即用管理器：负责列举设备，加载并初始化设备所需的驱动程序。还负责检测系统中的设备变化。</li>
<li>安全引用监视器（SRM）：该组件强制在本地计算机上实施安全策略，它守护着操作系统的资源，执行对象的保护和审计。</li>
<li>配置管理器：管理系统注册表，提供系统配置和启动信息。</li>
<li>I/O管理器：实现了与设备无关的输入和输出功能，负责将I/O请求分发给正确的设备驱动程序以便进一步处理。</li>
<li>对象管理器：它负责创建、管理、删除Windows执行体对象，以及用于表达操作系统资源的抽象数据类型，比如进程、线程和各种同步对象。</li>
<li>局域网管理器（本地过程调用，LPC）：负责处理进程之间的通信，管理消息传递和远程过程调用。</li>
</ul>
<h4 id="设备驱动程序"><a class="markdownIt-Anchor" href="#设备驱动程序"></a> 设备驱动程序</h4>
<p>在内核中除了内核模块<code>ntoskrnl.exe</code>和<code>HAL</code>以外，其他模块几乎都以设备驱动程序的形式存在。</p>
<p>Windows中的设备驱动程序，并不一定对应物理设备；它既可以创建虚拟设备，也可以与设备无关，它仅仅是内核的扩展模块。从软件结构角度而言，可以认为设备驱动程序是Windows内核的一种扩展机制，系统通过设备驱动程序来支持新的物理设备或者扩展功能。</p>
<p>设备驱动程序是可以加载到系统中的模块，其文件扩展名为**.sys**，其格式是标准的 <code>PE文件格式</code>。驱动程序中的代码运行在内核下，尽管它们可以直接操纵硬件，但理想的情况是，<code>调用HAL中的函数与硬件打交道</code>，因此，<code>驱动程序往往用C/C++语言来编写</code>	，从而可以方便地在Windows所支持的体系结构之间进行源代码层次上的移植。</p>
<p>根据设备驱动程序的功能和行为可以将设备驱动程序分为三类：</p>
<ul>
<li>即插即用驱动程序：支持即插即用技术的驱动程序。它们可以在设备连接到计算机时自动被识别和配置，无需用户手动干预。</li>
<li>非即插即用驱动程序：不支持即插即用技术的驱动程序。可能在安装时需要用户手动配置。</li>
<li>文件系统驱动程序：专门用于处理文件操作的驱动程序，如管理文件的存取、文件系统的结构等。</li>
</ul>
<p>即插即用驱动程序，也可以称为WDM（Windows Driver Model）驱动程序。WDM是一种设备驱动模型，它提供了一个统一的框架，使驱动程序可以在不同版本的WIndwos操作系统上运行。<br />
WDM通常分为三个层次：</p>
<ul>
<li>总线驱动程序：负责管理总线上的设备，也为总线上的设备提供了访问总线资源的方法。</li>
<li>功能驱动程序：负责管理具体的设备，向操作系统提供该设备的功能。</li>
<li>筛选/过滤驱动程序：监视一个设备的I/O请求以及其处理过程，增加或改变一个设备或驱动程序的行为。<br />
在WDM中，每个硬件设备都有一个设备驱动程序栈（简称设备栈），其中包含一个总线驱动程序和一个功能驱动程序，以及零个或多个过滤驱动程序。</li>
</ul>
<h4 id="文件系统存储管理"><a class="markdownIt-Anchor" href="#文件系统存储管理"></a> 文件系统/存储管理</h4>
<p>在现代操作系统中，<strong>文件系统是外部存储设备的标准接口，它为应用程序使用这些设备中的数据提供了统一的抽象</strong>，多个应用程序和系统本身可以共享使用这些设备。</p>
<p>在Windows中，文件系统的接口部分由I/O管理器定义和实现，但文件系统的实现部分位于专门的一类驱动程序中。但文件系统接收到I/O请求时，它会根据文件系统格式规范，将这些请求转变为更底层的对于外部存储设备的I/O请求，通过它们的设备驱动程序来完成原始的I/O请求。</p>
<p>因此，文件系统的驱动程序定义了外部存储设备中数据的逻辑结构，使得这些数据可直接被操作系统和应用程序使用。</p>
<p>这些文件系统驱动程序负责管理磁盘上的文件和目录，处理文件的创建、读取、写入和删除操作，提供了文件存储和访问的基本功能。</p>
<p>常见的文件系统：</p>
<p><strong>NTFS（NT File System）</strong>：这是Windows的原生文件系统，其驱动程序为ntfs.sys。NTFS是专门为Windows设计的，它提供了许多高级的如元数据支持、数据压缩加密的功能，同时支持大型存储卷和大文件。<br />
<strong>FAT（File Allocation Table）</strong>：这是从DOS时代发展起来的文件系统格式，格式规范相对简单，目前主要用于兼容老版本的操作系统，以及用于移动设备以便跨操作系统传送数据。<br />
文件系统的底层是对存储设备的管理。大容量存储设备以“分区（Partition）”和“卷（volume）”来管理整个存储空间。</p>
<p>分区是指存储设备上连续的存储区域（连续的扇区），而卷是指扇区的逻辑集合。一个卷内部的扇区可能来自一个分区，也可能来自多个分区，甚至来自不同的磁盘。文件系统则是卷内部的逻辑结构。</p>
<h4 id="网络"><a class="markdownIt-Anchor" href="#网络"></a> 网络</h4>
<p>在Windows操作系统中，网络是由一系列<strong>网络驱动程序</strong>和<strong>网络协议栈</strong>组成。</p>
<p>Windows内核层中的网络相关组件：</p>
<ul>
<li><strong>网络驱动程序（Network Drivers）</strong>：负责管理物理网络接口卡（NIC）或虚拟网络适配器的通信。</li>
<li><strong>协议栈（Protocol Stack）</strong>：是一个多层次的协议栈，用于处理网络通信。这个协议栈包括了各种网络协议，如TCP/IP、UDP、ICMP等。协议栈负责数据包的封装、路由、传输和解包，确保数据在网络中的正确传输。</li>
<li><strong>套接字（Sockets）</strong>：套接字是应用程序与网络协议栈之间的接口，允许应用程序创建网络连接、发送和接收数据。Windows内核还提供了套接字API，应用程序可以使用这些API与网络进行交互。</li>
<li><strong>网络服务（Network Services）</strong>：Windwos操作系统还提供了各种网络服务，如DHCP客户端、DNS客户端、网络发现服务等，它们能够进行获取IP地址，解析域名或发现网络设备等操作。</li>
<li><strong>网络筛选器驱动程序（Network Filter Drivers）</strong>：该驱动程序允许实施网络策略和安全性控制，如防火墙和安全软件可能会使用网络筛选器驱动程序来监视和过滤网络流量。</li>
</ul>
<p>Windows为应用程序提供了多种网络API：</p>
<ul>
<li>
<p><strong>Winsock（Windows Sockets）</strong> ： 套接字API，允许应用程序使用套接字进行网络通信。可以使用Winsock来创建TCP/IP和UDP网络连接，发送和接收数据。</p>
</li>
<li>
<p>HTTP API：允许应用程序创建HTTP服务器和客户端，发送HTTP请求、接收HTTP响应，并处理Web服务。</p>
</li>
<li>
<p>WebSocket API：这是一种双向通信的说协议，允许实时数据传输，适用于在线游戏、即时聊天等应用。</p>
</li>
<li>
<p>WebRTC API：一种用于实时音视频通信的开放标准，可以用于创建支持视频会议、实时音频通话等应用程序。</p>
</li>
<li>
<p>UPnP API：一种用于自动发现和配置网络设备的协议。</p>
</li>
<li>
<p>WinINet API：WinINet提供了对Internet资源的访问，包括HTTP、FTP和Gopher等协议，它允许应用程序进行Web页面下载、文件上传和下载等操作。</p>
</li>
<li>
<p>Network Management API：网络管理API，允许应用程序管理网络设置、配置网络连接和查看网络状态。</p>
</li>
</ul>
<p>这些网络API都提供了用户模式的动态链接库（DLL）。当应用程序通过这些DLL发出网络I/O请求时，它们将这些请求传递给内核中相应的驱动程序。通常，这些网络API要么通过专门的系统服务切换到内核模式，比如命名管道和邮件槽就有专门的系统服务；要么通过标准的系统服务接口，比如NtReadFile、NtWriteFile和NtDeviceIoControlFile，由I/O管理器和对象管理器将网络请求转送至对应的驱动程序中。</p>
<h4 id="windows子系统"><a class="markdownIt-Anchor" href="#windows子系统"></a> Windows子系统</h4>
<p>Windows子系统是Windows操作系统的组成部分，用于支持不同类型的应用程序和环境在Windows平台上运行。每个子系统专门设计用于处理特定类型的应用程序和操作环境。</p>
<p>Windows提供了多种子系统，同时在PE文件格式中的SubSystem域指示了可执行文件的子系统类型，即程序应在何种环境下运行；SubSystem域通常包含一个数字值，代表不同的子系统类型。</p>
<p>以下是一些常见的SubSystem及其对应的子系统：</p>
<p>Native (0)：</p>
<p>Native子系统表示该PE文件是一个本地的执行文件，通常是驱动程序或操作系统内核组件。这些文件在操作系统内核模式下运行。</p>
<p>Windows GUI (2)：</p>
<p>Windows GUI子系统表示该PE文件是一个图形用户界面（GUI）应用程序。它运行在Windows桌面环境中，通常有用户界面和窗口。</p>
<p>Windows CUI (3)：</p>
<p>Windows CUI子系统表示该PE文件是一个字符用户界面（CUI）应用程序。它通常是命令行应用程序，没有图形界面，用户通过控制台来与之交互。</p>
<p>OS/2 CUI (5)：</p>
<p>OS/2 CUI子系统表示该PE文件是一个OS/2字符用户界面应用程序。这种类型的应用程序通常用于运行在IBM OS/2环境中。</p>
<p>Posix CUI (7)：</p>
<p>Posix CUI子系统表示该PE文件是一个POSIX兼容的字符用户界面应用程序。它适用于在Windows上运行UNIX/Linux应用程序。</p>
<p>Windows子系统中既有用户模式部分，也有内核模式部分。内核模式部分的核心是win32k.sys，虽然它的形式是一个驱动程序，但实际上它并不处理I/O请求，相反，它向代码提供大量的系统服务。从功能上讲，它包含俩部分：窗口管理和图形设备接口。其中窗口管理部分负责收集和分发消息，以及控制窗口显示和管理屏幕输出；图形设备接口部分包含各种形状绘制以及文本输出功能。</p>
<h4 id="窗口管理"><a class="markdownIt-Anchor" href="#窗口管理"></a> 窗口管理</h4>
<p>Windows子系统的用户界面管理有一个<strong>层次结构</strong>，通常应用程序只是在一个默认的桌面上运行。</p>
<img src="/2024/07/09/%E5%88%9D%E8%AF%86Windows%E5%86%85%E6%A0%B8/a19524539f608cdeb3ead544362246b6.png" class="" alt="image-20240103144202326" loading="lazy">
<p>每个子系统会话都有自己的会话空间，属于某一个会话的资源将会从该会话空间中分配。当用户登录到Windwos中时，操作系统为该用户建立一个会话；即使用户通过远程桌面或者终端服务连接到一个系统中。系统也会为该用户建立一个单独的会话。</p>
<p>在一个会话中，有一个交互式窗口站，可能还有非交互式窗口站。在交互式窗口站中通常有三个桌面：登录桌面、默认桌面和屏幕保护桌面。交互式窗口站有独立的剪贴板、键盘、鼠标、显示器等，在它的三个桌面中，任一时刻只有一个是激活的，输入输出设备归激活的桌面所有。</p>
<p>在每个桌面，都有一个顶级窗口列表，这些窗口往往可以相互重叠，有系统菜单、最大化/最小化按钮和滚动条等。通常各个图形界面应用程序的主窗口属于当前桌面的顶级窗口。在Windows中，窗口可以有子窗口，子窗口占据父窗口的客户区域。因此，桌面上的窗口形成了一个层次结构。一个窗口下总是可以创建它自己的子窗口。</p>
<p>Windows为常用的窗口定义了一些窗口类（window class）。窗口类规定了其对象将如何响应各种信息，包括系统发送给它的消息和用户触发的消息。</p>
<p>Windows子系统会话有一个RIT（Raw Input Thread）线程，负责从输入设备读取原始的输入时间，生成消息寄送到正确的线程消息队列。</p>
<h4 id="图形设备接口"><a class="markdownIt-Anchor" href="#图形设备接口"></a> 图形设备接口</h4>
<p>Windows的图形引擎有俩方面特点：</p>
<ul>
<li>提供了一套与设备无关的编程接口，即GDI，这使得应用程序可以适应各种底层显示设备的差异</li>
<li>应用程序与图形设备驱动之间通信足够高效。在频繁输出和刷新图形元素的情况下，windows也能提供良好的视觉效果。</li>
</ul>
<img src="/2024/07/09/%E5%88%9D%E8%AF%86Windows%E5%86%85%E6%A0%B8/8390afe0659d26fa73af7df95095e051.png" class="" alt="image-20240103151555070" loading="lazy">
<p>上图是Windows子系统定义的图形体系结构。win32k.sys通过DDI（显示设备驱动程序接口）与现实驱动程序打交道，而显示驱动程序通过ENG（图形引擎接口）调用Win32k.sys中图形引擎的功能。</p>
<p>视频端口驱动程序实际上是一个动态链接库，用于辅助视频小端口驱动程序实现一些公共的、与图形有关的功能，以及为小端口驱动程序提供一个与系统内核和执行体打交道的环境。视频小端口驱动程序则直接负责的硬件资源管理和控制。</p>
<h4 id="系统线程和系统进程"><a class="markdownIt-Anchor" href="#系统线程和系统进程"></a> 系统线程和系统进程</h4>
<p><strong>系统线程</strong>则是一些特殊线程，与普通用户线程不同，系统线程不属于任何特定的用户进程，它直接运行在内核模式下。</p>
<p>一些常见的系统线程：</p>
<ul>
<li><strong>Idle线程</strong>：它的任务是在系统没有其他任务要执行时，占用CPU周期并降低CPU功耗，它通常属于最低优先级，以确保在需要时可以立即释放CPU资源给其他任务。</li>
<li><strong>Deferred Procedure Call (DPC) 线程</strong>：DPC线程是用于处理延迟的硬件中断请求的系统线程。当硬件设备产生中断请求时，DPC线程负责处理这些请求并执行相应的处理程序。</li>
<li><strong>System线</strong>程：System线程执行一些关键的内核操作，如系统调度、中断处理、内存管理等。它是操作系统的核心部分，用于协调和管理其他系统线程和用户进程。</li>
<li><strong>系统线程中还有一组系统辅助线程</strong>（system worker thred），它们代表操作系统或者其他的应用进程来完成一些特殊的工作。实际上，系统辅助线程是一个线程池，Windows在系统初始化时创建了一定数量的辅助线程，而且随着辅助线程的负载的变化，执行体也会动态地创建一些辅助线程，以满足系统负载的变化需求。</li>
</ul>
<p>在Windows操作系统中，有一些重要的系统进程，它们负责管理和控制操作系统的不同方面。</p>
<p>一些常见的系统进程：</p>
<ul>
<li><strong>系统空闲进程（Idle</strong>）：该进程的PID为0，其中每个处理器或核对应有一个线程。</li>
<li><strong>System 进程</strong>：这是操作系统的好恶心进程，PID为4。它负责管理内核模式下线程、设备驱动程序、中断处理和其他核心人物。</li>
<li><strong>会话管理器（smss.exe）</strong>：Windows系统中创建的第一个用户模式进程，在Windows启动过程中创建环境变量，（启动了子系统进程csrss.exe和登录进程winlogon.exe）。另外，它还负责创建新的终端服务器会话，包括建立会话空间的数据结构，为新建的终端服务器加载子系统。</li>
<li><strong>登录进程（winlogon.exe）</strong>：负责处理交互用户的登录和注销。<br />
Windows子系统进程（csrss.exe）：负责为用户提供一个子系统环境。</li>
<li><strong>本地安全权威子系统进程（lsass.exe）</strong>：负责本地系统安全策略。</li>
<li><strong>Shell进程（explorer.exe）</strong>：Windows的默认Shell，它提供了系统与用户打交道的各种界面，包括开始菜单、任务栏、资源管理窗口等几乎所有Windows用户都熟悉的界面。</li>
<li><strong>服务控制管理器（services.exe）</strong>：负责Windows的系统服务，指一些特殊的进程。</li>
</ul>
<h3 id="内核基本概念"><a class="markdownIt-Anchor" href="#内核基本概念"></a> 内核基本概念</h3>
<p>Windows内核中的各个组件并非单纯的独立模块，相反地，组件之间不可避免地包含了复杂的依赖关系，甚至存在交叉引用。下面是一些Windows内核中的基本概念。</p>
<h4 id="处理器模式"><a class="markdownIt-Anchor" href="#处理器模式"></a> 处理器模式</h4>
<p>用户模式下，处理器<strong>只能</strong>访问用户地址空间，而在内核模式下，处理器<strong>不仅</strong>可以访问用户地址空间，<strong>也</strong>可以访问系统地址空间。在内核模式下的代码和数据都是<strong>共享</strong>的，所有的进程一旦其指令流进入到内核模式下，则系统地址空间的代码和数据都是相同的。</p>
<p>一个指令流（即线程）在执行时，在以下情况会发生模式切换：</p>
<ul>
<li>用户模式代码触发了异常，则控制流进入到内核模式，内核中的异常处理函数可以决定该控制流是否继续执行。</li>
<li>用户模式代码执行时，被一个中断打断，控制流进入特权模式，等中断处理例程完成后，它若调用iret/iretd指令，则控制流恢复到用户模式下。</li>
<li>执行特殊的模式切换指令，如Intel x86的<code>sysenter</code>指令，从用户模式切换到内核模式。若想从内核模式切换到用户模式1，通常使用<code>sysexit</code>、<code>iret/iretd</code>这样的指令。</li>
</ul>
<p>由于系统空间是所有进程共享的，所以，任何一个进程在执行内核模式的代码时，实际上是在使用操作系统的服务。在Windows体系结构中，内核模式向上有一个执行体API，对于应用程序而言，这便是系统服务。</p>
<p>Windows将这些系统服务组织成了一张表，称为<strong>SDT（Service Descriptor Table，服务描述符表）</strong>。</p>
<h4 id="内存管理"><a class="markdownIt-Anchor" href="#内存管理"></a> 内存管理</h4>
<p>任何一个进程都定义了它自己完整的4GB地址空间（虚拟内存空间），在内存空间分布一图中，将其划分成2GB内核空间以及2GB应用空间，换句话说，内核空间是所有进程共享的，也称作<strong>系统地址空间</strong>，剩下的2GB空间才是它自己私有的，也叫<strong>进程地址空间</strong>。</p>
<p>为了有效管理2GB的系统地址空间，Windows将2GB划分成了一些固定的区域，主要包括：<strong>内核模块映像、PFN数据库、换页内存池、非换页内存池、会话空间、系统缓存区、系统视图以及页表</strong>等。</p>
<h4 id="分页机制"><a class="markdownIt-Anchor" href="#分页机制"></a> 分页机制</h4>
<p>Windows使用<strong>分页机制</strong>管理虚拟内存和物理内存。它将虚拟内存和物理内存划分成固定大小的页面，通过映射这些页面来实现虚拟地址到物理地址的转换。</p>
<p>通常操作系统将内存划分为<strong>大小固定的页面</strong>，通常为 <strong>4KB</strong>、8KB 或其他大小。这些页面是虚拟内存和物理内存的<strong>基本单位</strong>；之后操作系统将进程的虚拟地址空间也划分成页面大小的块。当程序访问进程的虚拟地址时，操作系统将虚拟地址转化成相应的物理地址。</p>
<p>为了实现虚拟地址到物理地址的转换，需要使用到页面表。</p>
<ul>
<li>页面表 是操作系统中的一个数据结构，<strong>用于记录虚拟地址空间中每个页面与实际物理内存中的对应关系。页面表的条目存储了虚拟页号到物理页号的映射关系。</strong></li>
<li>页面表中的每个条目称为<strong>页表项（Page Table Entry，PTE）</strong>。**每个 PTE 存储了虚拟页号到物理页号的映射，以及一些额外的控制信息，**例如页面是否在物理内存中、是否被修改等</li>
</ul>
<p>当程序访问进程的虚拟地址时，<strong>MMU</strong>负责将这个虚拟地址通过页面表转化成物理地址。</p>
<p>如果虚拟页已经在物理内存中，则直接获取物理地址。如果虚拟页不在物理内存中，就需要进行<strong>页面调度</strong>。</p>
<p><strong>页面调度</strong></p>
<ul>
<li>如果虚拟页不在物理内存中，会先引发一个 <strong>缺页异常</strong>。这时，操作系统需要根据页表中的信息确定要将哪一页加载到物理内存中。</li>
<li>然后操作系统会将当前没用的物理页写入磁盘中，将需要的虚拟页加载入物理页。</li>
</ul>
<p><strong>从内存中获取数据的过程</strong>：</p>
<ul>
<li>程序访问进程的虚拟地址</li>
<li>MMU在通过页面表查询虚拟地址对应的虚拟页是否在物理内存中</li>
<li>若在，直接获取物理地址，返回数据；</li>
<li>若不在，引发缺页异常，MMU在页面表中查找对应的虚拟页，通过页面调度将虚拟页加载到物理内存中</li>
<li>获取物理地址，返回数据。</li>
</ul>
<img src="/2024/07/09/%E5%88%9D%E8%AF%86Windows%E5%86%85%E6%A0%B8/20cb006fd5e9455bee6c3565a200ec2b.png" class="" alt="image-20231213214736149" loading="lazy">
<p><strong>至于数据在物理内存中还是虚拟内存中是没有规律的，取决于数据使用的频繁程度。</strong></p>
<h4 id="进程和线程管理"><a class="markdownIt-Anchor" href="#进程和线程管理"></a> 进程和线程管理</h4>
<p>**进程（process）**定义了一个执行环境，包括它自己的私有空间、一个句柄表、以及一个安全环境；<strong>线程（thread）是一个个控制流，有自己的调用栈（call stack）</strong>，记录它的执行历史。</p>
<p>一个进程包含一个或多个线程。</p>
<img src="/2024/07/09/%E5%88%9D%E8%AF%86Windows%E5%86%85%E6%A0%B8/bd58d8151f6e2f62337694a1f12a2df4.png" class="" alt="image-20240103195851417" loading="lazy">
<p><strong>用户模式下的进程只能访问进程地址空间，若在内核模式下，就可以访问真个地址空间。</strong></p>
<p>windows实现了**抢占式线程调度，每个线程都有一个基本优先级和动态优先级。本质上每个线程都处于俩种状态之一：满足继续执行的条件，正在排队或已经执行；不满足继续执行的条件，处于等待状态，或者它的调用栈升职所处的进程已经被换出内存。**在前一种情况下，线程按照优先级排队执行；对于多处理器系统，排队过程要更为复杂，不仅要处理多个队列，还要考虑每个处理器的就绪线程队列的平衡程度。还需要考虑处理器亲和性。</p>
<h4 id="中断和异常"><a class="markdownIt-Anchor" href="#中断和异常"></a> 中断和异常</h4>
<p><strong>中断（interrupt）<strong>是指</strong>处理器外部事件（如硬件设备）触发的信号</strong>，它会中断当前的处理器活动。<strong>异常（Exceptions）<strong>指</strong>程序执行过程中出现的非正常或意外情况</strong>，由处理器内部事件（如执行了错误指令）触发。</p>
<p>尽管中断和异常的触发来源和方式不同，但Intel x86处理器内部使用<strong>同一套陷阱机制</strong>来处理中断和异常，它利用<strong>IDT（Interrupt Descriptor Table，中断描述符表）</strong>，将每个中断或异常与一个处理该中断或异常的服务例程联系起来，因而一旦发生异常或中断，该相应的服务例程将被执行。Windows在此基础上，添加了一种更灵活的机制，允许设备驱动程序为特定的中断向量添加它的中断服务例程（ISR，Interrupt Service Routine）。一个中断向量允许连接多个中断对象（interrupt object），这里中断对象是一种封装了中断服务例程的内核对象。当中断发生时，这些中断对象中的服务例程都有机会处理该中断。通过中断对象机制，设备驱动程序可以在不操纵IDT的情况下加入它们的中断服务例程；另一方面，多个硬件设备也可以共享同样的硬件中断向量。</p>
<p>执行体层中介绍过中断请求级别IRQL。</p>
<p>异常是程序指令流执行过程中的同步处理过程，既可以由处理器硬件产生，也可以由指令流软件产生。Windows为所有需要处理的异常都提供了异常处理器（exception handler，即异常处理例程）。</p>
<h4 id="同步"><a class="markdownIt-Anchor" href="#同步"></a> 同步</h4>
<p>在现代操作系统中，由于多处理器、多核或者中断各种并发性（concurrency）因素的存在，同样的代码可能被<strong>并发执行</strong>，而数据也可能被并发访问。在这种情况下，对于可能被并发访问的数据进行必要的同步（synchronization）保护是一种常见的编程实践。<br />
一些同步中会遇到的概念：</p>
<ul>
<li>关于锁。什么是锁？<strong>锁是一种同步机制，用于确保在同一时刻只有一个线程能够访问共享资源；也就是保护临界区，确保在任何时刻只有一个线程可以进入临界区执行操作</strong>。锁包括<strong>互斥锁、自旋锁、读写锁</strong>等不同类型。</li>
<li>临界区。什么临界区？<strong>临界区是用于保护共享资源免受多个线程同时访问的一种同步机制：当一个线程进入临界区时，其他线程必须等待，直到第一个线程离开临界区。<strong>常用于</strong>用户模式下</strong>。</li>
</ul>
<p>Windows根据<strong>执行环境中的IRQL大于APC_LEVEL 或者等于PASSIVE_LEVEL</strong>，将同步机制分为“<strong>不依赖线程调度的同步机制</strong>”和“<strong>基于线程调度的同步机制</strong>”。</p>
<p>不依赖线程调度的同步机制主要是在IRQL的高优先级下执行的，通常用于中断处理程序和内核模式代码中，以确保在处理中断或执行关键内核代码时，不会被其他线程打断。常见的不依赖线程调度的同步机制包括：</p>
<ul>
<li><strong>自旋锁</strong>（Spin Lock）：<strong>自旋锁用于在多个线程之间互斥的访问共享资源，本质上是一种忙等待（busy-wait）</strong>，意思是**线程会一直自旋（忙等待）直到锁可用为止，而不会被挂起等待。**常使用在高IRQL下，因为此时是不允许切换线程的，使用自旋锁可以确保关键代码不会被其他线程打断。一些自旋锁扩展：执行体自旋锁（支持共享和独占的语义）、排队自旋锁（queued spin lock）和栈内排队自旋锁（in-stack queued spin lock）。</li>
<li><strong>中断服务例程（ISR）</strong>：ISR用于响应硬件中断，当硬件设备触发中断时，操作系统会立即执行ISR来处理中断。ISR运行在IRQL的高优先级下，不允许进行线程调度，以确保快速响应中断。</li>
<li><strong>延迟过程调用</strong>（Deferred Procedure Call，DPC）：DPC用于延迟执行一些代码块或处理程序，常与中断处理有关。当硬件设备触发中断时，操作系统会将**中断服务例程（ISR）**用于快速响应中断，但有时需要执行一些耗时的操作，例如数据传输或资源释放，这时就会使用DPC来延迟执行这些操作。</li>
</ul>
<p>另一种基于线程调度的同步机制：当一个线程的执行条件不满足时，该线程进入等待状态，系统将控制权交由其他满足执行条件但没有得到处理器资源的线程；以后，当该线程的执行条件满足时，它又有机会继续执行。这里的执行条件正是Windows提供的线程同步机制中的语义。Windows定义了统一的机制来支持各种线程同步原语：分发器对象（dispatcher object），其数据结构头部为DISAPATCH_HEADER。</p>
<p>常见的分发器对象：</p>
<ul>
<li>事件（event）：用于线程之间的通信和同步，它有俩种状态：已触发和未触发。事件可以用于线程等待某个事件发生，或者通知其他线程事件的发生。</li>
<li>互斥量（Mutex）：互斥量用于确保在同一时刻只有一个线程能够访问共享资源。它允许线程请求锁定，当一个线程获得锁定时，其他线程必须等待，直到锁被释放。</li>
<li>信号量（Semaphore）：用于控制对共享资源的并发访问。它维护一个计数器，允许指定数量的线程同时访问资源。<br />
条件变量（Condition Variable）：条件变量用于线程之间传递信号和等待特定条件的发生。通常与互斥量一起使用，用于等待某个条件满足后执行操作。</li>
<li>读写锁（Read-Write Locks）：读写锁用于控制对共享资源的读和写，它允许多个线程同时读取资源，但只允许一个线程写入资源。<br />
计数器对象（Counting Semaphore）：一种特殊的信号量，它可以增加和减少计数器的值，通常用于跟踪资源的可用性或完成的任务数量。<br />
**互斥锁（Mutex）**是一种基于线程调度的同步机制，它用于确保在同一时刻只有一个线程能够访问共享资源。当一个线程获得互斥锁的所有权后，其他线程必须等待，直到该线程释放锁。</li>
</ul>
<p>关于互斥锁和自旋锁：互斥锁基于线程调度，而自旋锁不依赖线程调度；还有一个区别是线程尝试获取锁时，如果该锁被占用，线程是被挂起还是一直自旋；互斥锁适用于长时间的临界区和资源竞争激烈的情况，而自旋锁适用于非常短暂的临界区。</p>
<p>Windows在上述基础上，实现了同步语义更为丰富的一些同步机制，包括：<strong>快速互斥体（fast mutex）</strong>、<strong>守护互斥体（guarded mutex）</strong>、<strong>执行体资源（executive resource）<strong>和</strong>推锁（push lock）</strong>。</p>
<hr />
<p>仅仅学习了概念方面的部分(概念比较多，现在仅仅是了解了一下比较重要的)，后期会进阶学习Windows系统相关的开发技术</p>
</div></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2024/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/" rel="prev" title="计算机网络学习笔记(一)"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">计算机网络学习笔记(一)</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2024/07/09/%E5%88%9D%E8%AF%86WindowsPE/" rel="next" title="初识WindowsPE"><span class="post-nav-text">初识WindowsPE</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>您需要科学上网，才可使用评论区功能。</span><br></div><div id="waline"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@waline/client@v2/dist/waline.css"><script>window.CONFIG.waline.config.path = "/2024/07/09/%E5%88%9D%E8%AF%86Windows%E5%86%85%E6%A0%B8/"</script><div class="js-Pjax"><script src="/js/comments/waline.js" type="module" defer></script></div></div></main><footer class="sidebar-translate" id="footer"><div class="beian"><a rel="noopener" href="https://beian.miit.gov.cn/" target="_blank"></a></div><div class="copyright"><span>&copy; 2023 – 2024 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> Npc</span></div><div class="footer-custom-text">=w=</div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="Search"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:search-line"></span></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="https://fastly.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js"></script><script src="/js/search/local-search.js" defer type="module"></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><span class="icon iconify" data-icon="ri:close-line"></span></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="Searching..." value=""></div><div class="search-result-container"></div></div><script src="https://fastly.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script><script>const images = [...document.querySelectorAll('.markdown-body img')]
mediumZoom(images)</script><style>.medium-zoom-image {
  z-index: 99;
}</style></body></html>