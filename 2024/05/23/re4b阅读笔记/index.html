<!DOCTYPE html><html lang="[&quot;en&quot;,&quot;zh-CN&quot;,&quot;default&quot;]"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="Npc"><meta name="copyright" content="Npc"><meta name="generator" content="Hexo 7.1.1"><meta name="theme" content="hexo-theme-yun"><title>re4b阅读笔记 | Npc | Blog</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.4.1/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism-coy.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"npc0vo.github.io","root":"/","title":"Npc小站","version":"1.10.11","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"local_search":{"path":"/search.xml"},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"fireworks":{"colors":null},"waline":{"config":{"enable":true,"serverURL":"https://waline-onelastchicks-projects.vercel.app/","comment":false,"el":"#waline","lang":["en","zh-CN","default"]},"cdn":"https://fastly.jsdelivr.net/npm/@waline/client@v2/dist/waline.js","dark":"html.dark"},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=G-1LL0D86CY9"></script><script>if (CONFIG.hostname === location.hostname) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-1LL0D86CY9');
}</script><script data-ad-client="ca-pub-2245427233262012" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><!-- Google Tag Manager --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-M9KWR9L');</script><!-- End Google Tag Manager --><meta name="description" content="Part.1 前言 阅读这种书籍，如果我不做笔记，我可能就会走马观花的粗略看一遍，结果什么都没学会，眼睛会了，脑子不会，所以我准备边做笔记边学，争取把基础打扎实 对于逆向工程权威指南关键部分的摘录,整理以及个人的理解 逆向工程权威指南是入门逆向必读的一本书籍 由于我是初学者，所以我目前只学习re4b x86汇编部分（不能贪多），对于ARM以及MIPS架构待以后进阶后再进行学习  Part.2 指">
<meta property="og:type" content="article">
<meta property="og:title" content="re4b阅读笔记">
<meta property="og:url" content="http://npc0vo.github.io/2024/05/23/re4b%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Npc | Blog">
<meta property="og:description" content="Part.1 前言 阅读这种书籍，如果我不做笔记，我可能就会走马观花的粗略看一遍，结果什么都没学会，眼睛会了，脑子不会，所以我准备边做笔记边学，争取把基础打扎实 对于逆向工程权威指南关键部分的摘录,整理以及个人的理解 逆向工程权威指南是入门逆向必读的一本书籍 由于我是初学者，所以我目前只学习re4b x86汇编部分（不能贪多），对于ARM以及MIPS架构待以后进阶后再进行学习  Part.2 指">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-05-23T08:25:47.000Z">
<meta property="article:modified_time" content="2024-06-06T05:34:42.166Z">
<meta property="article:author" content="Npc">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary"><script>(function() {
  if (CONFIG.mode !== 'auto') return
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="Npc"><img width="96" loading="lazy" src="/images/avatar.jpg" alt="Npc"><span class="site-author-status">😭</span></a><div class="site-author-name"><a href="/about/">Npc</a></div><span class="site-name">Npc | Blog</span><sub class="site-subtitle">想s</sub><div class="site-description"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">24</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">8</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">11</span></a></div><a class="site-state-item hty-icon-button" href="/about/#comment" title="留言板"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:clipboard-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/npc0vo" title="GitHub" target="_blank" style="color:#6e5494"><span class="icon iconify" data-icon="ri:github-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:me@1930278836@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><span class="icon iconify" data-icon="ri:mail-line"></span></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:genderless-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#part1-%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text"> Part.1 前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#part2-%E6%8C%87%E4%BB%A4%E8%AE%B2%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text"> Part.2 指令讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter1-cpu"><span class="toc-number">2.1.</span> <span class="toc-text"> Chapter1 CPU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chap2-%E6%9C%80%E7%AE%80%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.</span> <span class="toc-text"> Chap2 最简函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chap3-helloworld"><span class="toc-number">2.3.</span> <span class="toc-text"> Chap3 Hello,World!</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#msvs"><span class="toc-number">2.3.1.</span> <span class="toc-text"> msvs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gcc"><span class="toc-number">2.3.2.</span> <span class="toc-text"> gcc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#msvs-x86-64"><span class="toc-number">2.3.3.</span> <span class="toc-text"> msvs x86-64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gcc-x86-64"><span class="toc-number">2.3.4.</span> <span class="toc-text"> gcc x86-64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#problems"><span class="toc-number">2.3.5.</span> <span class="toc-text"> Problems</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chap4-%E5%87%BD%E6%95%B0%E5%BA%8F%E8%A8%80%E5%92%8C%E5%87%BD%E6%95%B0%E5%B0%BE%E5%A3%B0"><span class="toc-number">2.4.</span> <span class="toc-text"> Chap4 函数序言和函数尾声</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chap5-%E6%A0%88"><span class="toc-number">2.5.</span> <span class="toc-text"> Chap5 栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">2.5.1.</span> <span class="toc-text"> 栈的用途</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%99%AA%E9%9F%B3"><span class="toc-number">2.5.2.</span> <span class="toc-text"> 栈的噪音</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#problems-2"><span class="toc-number">2.5.3.</span> <span class="toc-text"> Problems</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#51"><span class="toc-number">2.5.3.1.</span> <span class="toc-text"> 5.1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#52"><span class="toc-number">2.5.3.2.</span> <span class="toc-text"> 5.2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chap6-printf%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">2.6.</span> <span class="toc-text"> Chap6 printf()函数与参数传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#x86"><span class="toc-number">2.6.1.</span> <span class="toc-text"> x86</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chap7-scanf"><span class="toc-number">2.7.</span> <span class="toc-text"> Chap7 scanf()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#x86-2"><span class="toc-number">2.7.1.</span> <span class="toc-text"> x86</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">2.7.2.</span> <span class="toc-text"> 全局变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#problem"><span class="toc-number">2.7.3.</span> <span class="toc-text"> Problem</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chap8-%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96"><span class="toc-number">2.8.</span> <span class="toc-text"> Chap8 参数获取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chap9-%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">2.9.</span> <span class="toc-text"> Chap9 返回值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#void%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">2.9.1.</span> <span class="toc-text"> void类型的返回值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%BA%E7%BB%93%E6%9E%84%E4%BD%93%E5%9E%8B%E6%95%B0%E6%8D%AE"><span class="toc-number">2.9.1.1.</span> <span class="toc-text"> 返回值为结构体型数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chap10-%E6%8C%87%E9%92%88"><span class="toc-number">2.10.</span> <span class="toc-text"> Chap10 指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chap12-%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB"><span class="toc-number">2.11.</span> <span class="toc-text"> Chap12 条件转移</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E6%AF%94%E8%BE%83"><span class="toc-number">2.11.1.</span> <span class="toc-text"> 数值比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E7%BB%9D%E5%AF%B9%E5%80%BC"><span class="toc-number">2.11.2.</span> <span class="toc-text"> 计算绝对值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.11.3.</span> <span class="toc-text"> 条件运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.11.4.</span> <span class="toc-text"> 比较大小</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chap13-switch"><span class="toc-number">2.12.</span> <span class="toc-text"> Chap13 Switch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#case%E8%BE%83%E5%B0%91%E7%9A%84%E6%83%85%E5%BD%A2"><span class="toc-number">2.12.1.</span> <span class="toc-text"> case较少的情形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#case%E8%BE%83%E5%A4%9A%E7%9A%84%E6%83%85%E5%BD%A2"><span class="toc-number">2.12.2.</span> <span class="toc-text"> case较多的情形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#case%E4%BB%8E%E5%8F%A5%E5%A4%9A%E5%AF%B9%E4%B8%80"><span class="toc-number">2.12.3.</span> <span class="toc-text"> case从句多对一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fall-through"><span class="toc-number">2.12.4.</span> <span class="toc-text"> fall-through</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chap14-%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.13.</span> <span class="toc-text"> Chap14 循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#for"><span class="toc-number">2.13.1.</span> <span class="toc-text"> for</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%9D%97%E5%A4%8D%E5%88%B6"><span class="toc-number">2.13.2.</span> <span class="toc-text"> 内存块复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.13.3.</span> <span class="toc-text"> 总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#problem-2"><span class="toc-number">2.13.4.</span> <span class="toc-text"> Problem</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chap15-c%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.14.</span> <span class="toc-text"> Chap15 C语言字符串的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#strlen"><span class="toc-number">2.14.1.</span> <span class="toc-text"> strlen()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chap16-%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9B%BF%E6%8D%A2"><span class="toc-number">2.15.</span> <span class="toc-text"> Chap16 数学计算指令的替换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%98%E6%B3%95"><span class="toc-number">2.15.1.</span> <span class="toc-text"> 乘法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E4%B8%BA%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">2.15.1.1.</span> <span class="toc-text"> 替换为加法运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E4%B8%BA%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">2.15.1.2.</span> <span class="toc-text"> 替换为移位运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E4%B8%BA%E7%A7%BB%E4%BD%8D%E5%8A%A0%E5%87%8F%E6%B3%95%E7%9A%84%E6%B7%B7%E5%90%88%E8%BF%90%E7%AE%97"><span class="toc-number">2.15.1.3.</span> <span class="toc-text"> 替换为移位,加减法的混合运算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">2.15.2.</span> <span class="toc-text"> 除法运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E4%B8%BA%E4%BD%8D%E7%A7%BB%E8%BF%90%E7%AE%97"><span class="toc-number">2.15.2.1.</span> <span class="toc-text"> 替换为位移运算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#problem-3"><span class="toc-number">2.15.3.</span> <span class="toc-text"> Problem</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chap17-fpu"><span class="toc-number">2.16.</span> <span class="toc-text"> Chap17 FPU</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="toc-number">2.16.0.1.</span> <span class="toc-text"> 利用参数传递浮点型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E8%AF%B4%E6%98%8E"><span class="toc-number">2.16.0.2.</span> <span class="toc-text"> 比较说明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chap18-%E6%95%B0%E7%BB%84"><span class="toc-number">2.17.</span> <span class="toc-text"> Chap18 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA"><span class="toc-number">2.17.1.</span> <span class="toc-text"> 缓冲区溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">2.17.2.</span> <span class="toc-text"> 其他</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8C%87%E9%92%88"><span class="toc-number">2.17.3.</span> <span class="toc-text"> 字符串指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">2.17.4.</span> <span class="toc-text"> 多维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E7%9A%84%E5%B0%81%E8%A3%85%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.17.5.</span> <span class="toc-text"> 二维字符串数组的封装格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#problem-4"><span class="toc-number">2.17.6.</span> <span class="toc-text"> Problem</span></a></li></ol></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="http://npc0vo.github.io/2024/05/23/re4b%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Npc"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Npc | Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">re4b阅读笔记</h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="Created: 2024-05-23 16:25:47" itemprop="dateCreated datePublished" datetime="2024-05-23T16:25:47+08:00">2024-05-23</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-2-line"></span></span> <time title="Modified: 2024-06-06 13:34:42" itemprop="dateModified" datetime="2024-06-06T13:34:42+08:00">2024-06-06</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="Word count in article"><span class="icon iconify" data-icon="ri:file-word-line"></span></span> <span title="Word count in article">25.9k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="Reading time"><span class="icon iconify" data-icon="ri:timer-line"></span></span> <span title="Reading time">114m</span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><span class="icon iconify" data-icon="ri:folder-line"></span></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/Reverse/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">Reverse</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">学习笔记</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h1 id="part1-前言"><a class="markdownIt-Anchor" href="#part1-前言"></a> Part.1 前言</h1>
<p>阅读这种书籍，如果我不做笔记，我可能就会走马观花的粗略看一遍，结果什么都没学会，眼睛会了，脑子不会，所以我准备边做笔记边学，争取把基础打扎实</p>
<p>对于逆向工程权威指南关键部分的摘录,整理以及个人的理解</p>
<p>逆向工程权威指南是入门逆向必读的一本书籍</p>
<p>由于我是初学者，所以我目前只学习re4b x86汇编部分（不能贪多），对于ARM以及MIPS架构待以后进阶后再进行学习</p>
<h1 id="part2-指令讲解"><a class="markdownIt-Anchor" href="#part2-指令讲解"></a> Part.2 指令讲解</h1>
<h2 id="chapter1-cpu"><a class="markdownIt-Anchor" href="#chapter1-cpu"></a> Chapter1 CPU</h2>
<p>**指令码：**CPU受理的底层命令。典型的底层命令有：将数据在寄存器间转移、操作内存、计算运算等指令。每类CPU都有自己的指令集架构（Instruction Set Architecture，ISA）。</p>
<p>**机器码：**发送给CPU的程序代码。一条指令通常被封装为若干字节。</p>
<p>**汇编语言：**为了让程序员少长白头发而创造出来的、易读易记的代码，它有很多类似宏的扩展功能。</p>
<p>**CPU寄存器：**每种CPU都有其固定的通用寄存器（GPR）。x86 CPU里一般有8个GPR，x64里往往有16个GPR，而ARM里则通常有16个GPR。您可以认为CPU寄存器是一种存储单元，它能够无差别地存储所有类型的临时变量。假如您使用一种高级的编程语言，且仅会使用到8个32位变量，那么光CPU自带的寄存器就能完成不少任务了！</p>
<p><strong>指令集架构</strong></p>
<p>最常见的三种</p>
<ul>
<li>
<p>ARM指令集分为3类：ARM模式指令集、Thumb模式指令集（包括Thumb-2）和ARM64的指令集。需要强调的是：不同的指令集分别</p>
<p>属于不同的指令集架构；一个指令集绝非另一个指令集的变种。</p>
</li>
<li>
<p>x86指令集 各opcode（汇编指令对应的机器码）的长度不尽相同</p>
</li>
<li>
<p>MIPS指令集 多数都使用了固定长度的32位opcode</p>
</li>
</ul>
<p><strong>汇编语言</strong>存在两种主流语体，即<strong>Intel语体</strong>和<strong>AT&amp;T语体</strong></p>
<h2 id="chap2-最简函数"><a class="markdownIt-Anchor" href="#chap2-最简函数"></a> Chap2 最简函数</h2>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">f:
	mov eax,123
	ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这个函数仅由两条指令构成：第一条指令把数值123存放在EAX寄存器里；根据函数调用约定,后面一条指令会把EAX的值当作返回值传递给调用者函数，而调用者函数（caller）会从EAX寄存器里取值，把它当作返回结果。</p>
<h2 id="chap3-helloworld"><a class="markdownIt-Anchor" href="#chap3-helloworld"></a> Chap3 Hello,World!</h2>
<h3 id="msvs"><a class="markdownIt-Anchor" href="#msvs"></a> msvs</h3>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello,world!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用MSVS<code>cl 1.cpp /Fa1.asm</code>生成<code>1.asm</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">CONST   SEGMENT
$SG3830 DB       &#39;hello, world&#39;, 0AH, 00H
CONST   ENDS
PUBLIC  _main
EXTRN   _printf:PROC
; Function compile flags: &#x2F;Odtp
_TEXT   SEGMENT
_main   PROC
        push    ebp
        mov     ebp, esp
        push    OFFSET $SG3830
        call    _printf
        add     esp, 4
        xor     eax, eax
        pop     ebp
        ret     0
_main   ENDP
_TEXT   ENDS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>生成<code>1.asm</code>后，编译器会生成<code>1.obj</code>然后再链接为<code>1.exe</code></p>
<p>对这段汇编的解读</p>
<ul>
<li>
<p>文件分为两个代码段，即CONST和_TEXT段，它们分别代表数据段和代码段。</p>
</li>
<li>
<p>字符串常量“hello，world”分配了一个指针（const char[]），只是在代码中这个指针的名称并不明显</p>
</li>
<li>
<p>编译器进行了自己的处理，并在内部把字符串常量命名为$SG3830,<code>0AH</code>是换行符</p>
<p>可以发现在字符串常量尾部添加了<code>00H</code>这个是字符串常量的结束标志,编译器添加的</p>
</li>
<li>
<p>在代码段<code>_TEXT</code>只有一个函数，即<code>main()</code>,其中<code>PROC</code>是<code>Procdure</code>的缩写，表示程序的开始,与<code>ENDP</code>配对使用</p>
</li>
<li>
<p>主函数的函数体有标志性的函数序言（function prologue）</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">push ebp        ; 保存调用者的栈帧指针
mov ebp, esp    ; 建立当前函数的栈帧指针
sub esp, N      ; 为局部变量分配空间（N 是需要分配的字节数）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>以及函数尾声（function epilogue）</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov esp, ebp    ; 恢复栈指针
pop ebp         ; 恢复调用者的栈帧指针
ret             ; 返回到调用者<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>实际上所有的函数都有这样的序言和尾声。</p>
</li>
<li>
<p>在函数序言之后，看到调用<code>printf()</code>的指令<code>CALL _printf</code></p>
<p>通过<code>PUSH</code>指令，程序把字符串的指针推送入栈。这样，<code>printf()</code>函数就可以调用栈里的指针，即字符串<code>“hello, world!”</code>的地址。</p>
</li>
<li>
<p>在<code>printf()</code>函数结束以后，程序的控制流会返回到<code>main()</code>函数之中。此时，字符串地址（即指针）仍残留在数据栈之中。这个时候就需要调整栈指针（ESP寄存器里的值）来释放这个指针。</p>
</li>
<li>
<p>下一条语句是<code>“add ESP，4”</code>，把ESP寄存器（栈指针/Stack Pointer）里的数值加4。(在32位系统中，指针的大小占4字节，同理在64位中，就要+8)</p>
<p>这条指令可以理解为“POP某寄存器”。只是本例的指令直接舍弃了栈里的数据而POP指令还要把寄存器里的值存储到既定寄存器</p>
<p>某些编译器（如Intel C<ins>编辑器）不会使用ADD指令来释放数据栈，<strong>它们可能会用POP ECX指令</strong>。例如，Oracle RDBMS（由Intel C</ins>编译器编译）就会用POP ECX指令，而不会用ADD指令。虽然POP ECX命令确实会修改ECX寄存器的值，但是它也同样释放了栈空间。</p>
<p>Intel C++编译器使用POP ECX指令的另外一个理由就是，<strong>POP ECX对应的OPCODE（1字节）比ADD ESP的OPCODE（3字节）要短。</strong></p>
</li>
<li>
<p>在上述程序中printf()函数结束之后，main()函数会返回0（函数正常退出的返回码）。即main()函数的运算结果是0。这个返回值是由<strong>指令<code>“XOR EAX, EAX”</code>计算出来的</strong>。编译器通常采用异或运算指令，而不会使用“MOV EAX，0”指令。主要是因为<strong>异或运算的opcode较短</strong>（2字节:5字节）</p>
</li>
<li>
<p>汇编列表中最后的操作指令是RET，将控制权交给调用程序。通常它起到的作用就是将控制权交给操作系统，这部分功能由C/C++的<code>CRT</code>实现。（C RUNTIME LIBRARY)</p>
</li>
</ul>
<h3 id="gcc"><a class="markdownIt-Anchor" href="#gcc"></a> gcc</h3>
<p>利用<code>gcc</code>编译器编译<code>gcc 1.c -o 1</code>采用<code>-S -masm=intel</code>生成intel语法的汇编列表文件</p>
<p>生成后用IDA打开</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">Main         proc near
var_10       &#x3D; dword ptr -10h

             push    ebp
             mov     ebp, esp
             and     esp, 0FFFFFFF0h
             sub     esp, 10h
             mov     eax, offset aHelloWorld ; &quot;hello, world\n&quot;
             mov     [esp+10h+var_10], eax
             call    _printf
             mov     eax, 0
             leave
             retn
main         endp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>汇编解读</p>
<ul>
<li>与MSVC生成的结果基本相同。它首先把“hello, world”字符串在数据段的地址（指针）存储到EAX寄存器里，然后再把它存储在数据栈里。</li>
<li>开头的<code>and esp,0FFFFFFF0h</code>向16字节边界对齐（成为16的整数倍），属于初始化的指令。如果地址位没有对齐，那么CPU可能需要访问两次内存才能获得栈内数据。虽然在8字节边界处对齐就可以满足32位x86 CPU和64位x64 CPU的要求，但是主流编译器的编译规则规定“程序访问的地址必须向16字节对齐（被16整除）,目的是为了提高效率</li>
<li><code>“SUB ESP，10h”</code>将在栈中分配0x10 bytes，即16字节。我们在后文看到，程序只会用到4字节空间。但是因为编译器对栈地址（ESP）进行了16字节对齐，所以每次都会分配16字节的空间。</li>
<li>而后，程序将字符串地址（指针的值）直接写入到数据栈。此处，GCC使用的是MOV指令；而MSVC生成的是PUSH指令。其中var_10是局部变量，用来向后面的printf()函数传递参数。</li>
<li>GCC和MSVC不同，除非人工指定优化选项，否则它会生成与源代码直接对应的“MOV EAX, 0”指令。但是，我们已经知道MOV指令的opcode肯定要比XOR指令的opcode长。</li>
<li>LEAVE指令，简化函数尾声，等效于<code>“MOV ESP, EBP”</code>和“<code>POP EBP”</code>两条指令。可见，这个指令调整了数据栈指针ESP，并将EBP的数值恢复到调用这个函数之前的初始状态。</li>
</ul>
<h3 id="msvs-x86-64"><a class="markdownIt-Anchor" href="#msvs-x86-64"></a> msvs x86-64</h3>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">$SG2989  DB      &#39;hello, world&#39;, 0AH 00H

main     PROC
         sub     rsp, 40
         lea     rcx, OFFSET FLAT:$SG2989
         call    printf
         xor     eax, eax
         add     rsp, 40
         ret     0
main     ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在x86-64框架的CPU里，所有的物理寄存器都被扩展为64位寄存器。寄存器变为r字开头</p>
<p>为了尽可能充分地利用寄存器、减少访问内存数据的次数，编译器会充分利用寄存器传递函数参数（请参见64.3节的fastcall约定）。也就是说，编译器会优先使用寄存器传递部分参数，再利用内存（数据栈）传递其余的参数。<code>Win64的程序</code>还会使用<code>RCX、RDX、R8、R9</code>这4个寄存器来存放函数参数。我们稍后就会看到这种情况：printf()使用RCX寄存器传递参数，而没有像32位程序那样使用栈传递数据。</p>
<p>main()函数的返回值是整数类型的零，但是出于兼容性和可移植性的考虑，C语言的编译器仍将使用<code>32位的零</code>。换而言之，即使是64位的应用程序，在程序结束时EAX的值是零，而R<code>AX的值不一定会是零。</code></p>
<p>数据栈的对应空间里仍留有40字节的数据。这部分数据空间有个专用的名词，即<code>阴影空间</code>（shadow space）</p>
<h3 id="gcc-x86-64"><a class="markdownIt-Anchor" href="#gcc-x86-64"></a> gcc x86-64</h3>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.string &quot;hello, world\n&quot;
main:
         sub      rsp, 8
         mov      edi, OFFSET FLAT:.LC0 ; &quot;hello, world&quot;
         xor      eax, eax  ; number of vector registers passed
         call     printf
         xor      eax, eax
         add      rsp, 8
         ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>Linux、BSD和Mac OS X系统中的应用程序</strong>，会优先使用<code>RDI、RSI、RDX、RCX、R8、R9这6个寄存器传递函数所需的头6个参数</code>，然后使用数据栈传递其余的参数。</p>
<p>使用了<code>EDI</code>寄存器来传递字符串指针，为什么不用<code>RDI</code></p>
<p>需要注意的是，64位汇编指令MOV在写入R-寄存器的低32位地址位的时候，即对E-寄存器进行写操作的时候，会同时清除R-寄存器中的高32位地址位。所以, “MOV EAX, 011223344h”能够对RAX寄存器进行正确的赋值操作，因为该指令会清除（置零）高地址位的内容。</p>
<p>使用<code>EDI</code>是因为可以使<code>opcode</code>由7个字节减少到5个字节,gcc优化</p>
<p><code>gcc</code>的优化有很多特性，例如:它可能会把字符串拆出来单独使用。以节省内存</p>
<h3 id="problems"><a class="markdownIt-Anchor" href="#problems"></a> Problems</h3>
<p>1.答:调用了<code>MessagBeep</code>这个函数，参数为0xFFFFFFFF</p>
<h2 id="chap4-函数序言和函数尾声"><a class="markdownIt-Anchor" href="#chap4-函数序言和函数尾声"></a> Chap4 函数序言和函数尾声</h2>
<p>略</p>
<h2 id="chap5-栈"><a class="markdownIt-Anchor" href="#chap5-栈"></a> Chap5 栈</h2>
<ul>
<li>
<p>栈就是CPU寄存器里的某个指针所指向的一片内存区域。这里所说的“某个指针”通常位于x86/x64平台的ESP寄存器/RSP寄存器，以及ARM平台的SP寄存器。</p>
</li>
<li>
<p>操作栈的最常见的指令是PUSH和POP，<code>PUSH</code>指令会对ESP/RSP/SP寄存器的值进行减法运算，使之减去4（32位）或8（64位），然后将操作数写到上述寄存器里的指针所指向的内存中。<code>POP</code>指令是PUSH指令的逆操作：它先从栈指针（Stack Pointer，上面三个寄存器之一）指向的内存中读取数据，用以备用（通常是写到其他寄存器里），然后再将栈指针的数值加上4或8。</p>
</li>
<li>
<p>栈是逆增长的，即从高地址向低地址增长</p>
</li>
</ul>
<hr />
<h3 id="栈的用途"><a class="markdownIt-Anchor" href="#栈的用途"></a> 栈的用途</h3>
<ul>
<li>
<p>保存函数的返回地址</p>
<p><code>call</code>指令等价于<code>push 返回地址</code>与<code>jmp 函数地址</code></p>
<p><code>ret</code>指令从栈中读取返回地址，然后跳转到这个地址，等价于<code>pop 返回地址</code>与<code>jmp 返回地址</code></p>
<p>由此可实现函数的递归调用</p>
</li>
<li>
<p>参数传递</p>
<p>最常用的参数传递约定是<code>cdecl</code></p>
<p>以下为其主要规则</p>
<ol>
<li><strong>参数从右到左压入栈</strong></li>
<li><strong>调用者负责清理栈</strong>：函数调用结束后，调用者需要负责从栈中弹出传递给函数的所有参数。这意味着编译器会在调用函数之后生成相应的代码来调整堆栈指针，恢复调用前的状态。</li>
<li><strong>可变参数列表支持</strong>：cdecl 支持函数具有可变数量的参数（如 printf 函数），这是通过在参数列表中使用省略号（…）来表示的。</li>
<li><strong>返回值通常在EAX寄存器中</strong>（对于x86架构）：大多数情况下，函数的返回值如果大小适当（比如整数、指针），会通过EAX寄存器返回。对于更大的返回类型，可能会通过其他方式，如通过指针传递。</li>
</ol>
<p>例如</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">push arg3
push arg2
push arg1
call f
add esp.12;4*3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>被调用的函数可以通过栈指针获取所需参数</p>
<table>
<thead>
<tr>
<th>ESP</th>
<th>返回地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>ESP+4</td>
<td>arg1, 它在IDA里记为arg_0</td>
</tr>
<tr>
<td>ESP+8</td>
<td>arg2, 它在IDA里记为arg_4</td>
</tr>
<tr>
<td>ESP+0xC</td>
<td>arg3, 它在IDA里记为arg_8</td>
</tr>
</tbody>
</table>
<p>需要注意的是，程序员可以使用栈来传递参数，也可以不使用栈传递参数。参数处理方面并没有相关的硬性规定。例如也可以用寄存器或者堆上开辟内存进行传参，不过在x86这种约定已是习惯</p>
<p>如果函数可处理的参数数量可变，就需要用说明符如%d进行格式化说明，明确参数信息</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d %d"</span><span class="token punctuation">,</span> <span class="token number">1234</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个命令不仅会让printf()显示1234，而且还会让它显示数据栈内1234之后的两个地址的随机数。</p>
<p>由此可知，声明main()函数的方法并不是那么重要。我们可以将之声明为<code>main(),main(int argc, char *argv[])或main(int argc, char *argv[], char *envp[])</code>,CRT中调用<code>main()</code>指令如下:</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">push envp
push argv
push argc
call main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li>
<p>存储局部变量</p>
</li>
<li>
<p>x86.alloca()函数</p>
<p><code>malloc()</code>是在堆上分配内存，而<code>alloc()</code>直接使用栈来分配内存</p>
<p>由于函数尾声的代码会还原<code>ESP</code>的值，不需要特地使用<code>free()</code>来释放内存</p>
</li>
<li>
<p>(Win)SEH结构化异常处理</p>
<p>如果程序里存在<code>SEH</code>记录，那么记录会保存在栈中</p>
</li>
<li>
<p>缓冲区溢出保护</p>
</li>
<li>
<p>典型的栈的内存存储格式</p>
<p>在32位系统中，在程序调用函数之后、执行它的第一条指令之前，栈在内存中的存储格式一般如下表所示。</p>
<table>
<thead>
<tr>
<th>…</th>
<th>……</th>
</tr>
</thead>
<tbody>
<tr>
<td>ESP-0xC</td>
<td>第2个局部变量，在IDA里记为var_8</td>
</tr>
<tr>
<td>ESP-8</td>
<td>第1个局部变量，在IDA里记为var_4</td>
</tr>
<tr>
<td>ESP-4</td>
<td>保存的EBP值</td>
</tr>
<tr>
<td>ESP</td>
<td>返回地址</td>
</tr>
<tr>
<td>ESP+4</td>
<td>arg1, 在IDA里记为arg_0</td>
</tr>
<tr>
<td>ESP+8</td>
<td>arg2, 在IDA里记为arg_4</td>
</tr>
<tr>
<td>ESP+0xC</td>
<td>arg3, 在IDA里记为arg_8</td>
</tr>
<tr>
<td>…</td>
<td>……</td>
</tr>
</tbody>
</table>
</li>
</ul>
<hr />
<h3 id="栈的噪音"><a class="markdownIt-Anchor" href="#栈的噪音"></a> 栈的噪音</h3>
<p>函数退出以后,原有栈的空间里的局部变量不会被自动清除，仍然保留就成了栈中的脏数据</p>
<p>例如</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>
        <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"%d, %d, %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">&#123;</span>
        <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们会发现，没有对f2的变量初始化，仍然打印的是 1 2 3</p>
<p>可以研究一下汇编代码,利用MSVS编译的代码如下</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">$SG2752 DB      &#39;%d, %d, %d&#39;, 0aH, 00H

_c$ &#x3D; -12       ; size &#x3D; 4
_b$ &#x3D; -8        ; size &#x3D; 4
_a$ &#x3D; -4        ; size &#x3D; 4
_f1    PROC
       push     ebp
       mov      ebp, esp
       sub      esp, 12
       mov      DWORD PTR _a$[ebp], 1
       mov      DWORD PTR _b$[ebp], 2
       mov      DWORD PTR _c$[ebp], 3
       mov      esp, ebp
       pop      ebp
       ret      0
_f1    ENDP

_c$ &#x3D; -12       ; size &#x3D; 4
_b$ &#x3D; -8        ; size &#x3D; 4
_a$ &#x3D; -4        ; size &#x3D; 4
_f2    PROC
       push     ebp
       mov      ebp, esp
       sub      esp, 12
       mov      eax, DWORD PTR _c$[ebp]
       push     eax
       mov      ecx, DWORD PTR _b$[ebp]
       push     ecx
       mov      edx, DWORD PTR _a$[ebp]
       push     edx
       push     OFFSET $SG2752 ; ’%d, %d, %d’
       call     DWORD PTR __imp__printf
       add      esp, 16
       mov      esp, ebp
       pop      ebp
       ret      0
_f2    ENDP

main   PROC
       push     ebp
       mov      ebp, esp
       call     _f1
       call     _f2
       xor      eax, eax
       pop      ebp
       ret      0
_main  ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这个特例里，第二个函数在第一个函数之后执行，而第二个函数变量的地址和SP的值又与第一个函数的情况相同。所以，相同地址的变量获得的值相同。</p>
<p>总而言之，在运行第二个函数时，栈中的所有值（即内存中的单元）受前一个函数的影响，而获得了前一个函数的变量的值。严格地说，这些地址的值不是随机值，而是可预测的伪随机值。</p>
<h3 id="problems-2"><a class="markdownIt-Anchor" href="#problems-2"></a> Problems</h3>
<h4 id="51"><a class="markdownIt-Anchor" href="#51"></a> 5.1</h4>
<p>如果使用MSVC编译、运行下列程序，将会打印出3个整数。这些数值来自哪里？如果使用MSVC的优化选项“/Ox”，程序又会在屏幕上输出什么？为什么GCC的情况完全不同？</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;

int main() 
&#123;
         printf (&quot;%d, %d, %d\n&quot;);

         return 0;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果未启用MSVC的优化编译功能，程序显示的数字分别是EBP的值、RA和argc。在命令行中执行相应的程序即可进行验证。</p>
<p>如果启用了MSVC的优化编译功能，程序显示的数字分别来自：返回地址RA、argc和数组argv［］。</p>
<p>GCC会给main() 函数的入口分配16字节的地址空间，所以输出内容会有不同。</p>
<h4 id="52"><a class="markdownIt-Anchor" href="#52"></a> 5.2</h4>
<p>答：打印时间</p>
<h2 id="chap6-printf函数与参数传递"><a class="markdownIt-Anchor" href="#chap6-printf函数与参数传递"></a> Chap6 printf()函数与参数传递</h2>
<p>演示程序</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a=%d,b=%d,c=%d"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用<code> g++ -m32 -o 1 1.c</code>进行编译或者使用<code>MSVS</code>工具链进行编译，跟随本书的节奏，配置一下<code>MSVS</code>的环境</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/build/building-on-the-command-line?view=msvc-170#download-and-install-the-tools">通过命令行使用 Microsoft C++ 工具集 | Microsoft Learn</a></p>
<p>首先将<code>Microsoft Visual Studio\2022\Community\VC\Auxiliary\Build</code>加入环境变量</p>
<p>命令行输入<code>vcvarsall.bat x86</code></p>
<p>然后<code>cl 1.cpp</code></p>
<hr />
<p>MSVS工具链一些常用的指令</p>
<p><code>cl /Fa 1.c</code>生成不带注释的汇编代码</p>
<p><code>cl /FAs 1.c</code>生成带注释的汇编代码,生成1.asm</p>
<p><code>dumpbin /all example.obj</code>显示目标文件中的所有信息，包括段内容、符号表和重定位信息。</p>
<p>/c 代表只编译不链接。</p>
<p>/I 指定头文件的目录</p>
<p>/C 在编译期间保留代码注释，这里和/I连在一起使用，/IC</p>
<p>首先介绍一个概念，VC中有个PDB文件，全称是Program Database，用来存放程序信息的小的<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/14">数据库</a>文件。</p>
<p>编译Debug版本时，调试信息需要保留，我们可以选择直接将调试信息写到.obj文件中，或者存到.pdb文件中。</p>
<p>/Z7 不产生.pdb文件，将所有调试信息存入.obj文件中</p>
<p>/Zi和/ZI 都产生.pdb文件，不过/ZI支持&quot;编辑继续调试&quot;功能, (the edit and continue feature), 看上去更酷，但是我从来没有用过这个功能。</p>
<p>/ZI有一些边际效应，会禁止#pragma optmize 指令，也不能和/clr一起用。</p>
<p>/nologo- 已经无效，自己生成命令行的时候，没必要用了。</p>
<p>/W3 也中警告级别，VC提供了很多警告级别，参考<a target="_blank" rel="noopener" href="http://msdn.microsoft.com/en-us/library/vstudio/thxezb7y.aspx">http://msdn.microsoft.com/en-us/library/vstudio/thxezb7y.aspx</a></p>
<p>自己编译的话，直接用/Wall最好。</p>
<p>/WX- 不太明白为什么有 - 号，（估计是和:NO的意思相同，也就是不启用该功能）， /WX的意思是将warning转变成error，这样强迫消除所有的warning，如果和/Wall一起使用，那是最好的。</p>
<p>/sdl 是对代码进行安全检查，如果发现相关警告，转变成错误输出</p>
<p>/Od 禁止优化</p>
<p>/Oy- 禁止该选项，该选项如果没有 - 号，则会在x86上编译时忽略frame-pointer，起到加速程序的作用。 frame-pointer，我暂时不知道是啥。</p>
<p>/D 预处理定义，后面可以跟不同的参数都是宏啊，比如<br />
/Gm 启用最小化重新编译, VC用.idb保留了上次编译的缓存信息，包括文件依赖关系。下次编译时可以使用.idb文件用来检查，跳过不需要重新编译的文件。</p>
<p>具体参见:</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/cpp/build/reference/compiler-options?view=msvc-170&amp;redirectedfrom=MSDN">MSVC Compiler Options | Microsoft Learn</a></p>
<h3 id="x86"><a class="markdownIt-Anchor" href="#x86"></a> x86</h3>
<p>MSVS编译得到的汇编指令如下</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">_TEXT	SEGMENT
_main	PROC

; 3    : &#123;

	push	ebp
	mov	ebp, esp

; 4    :     printf(&quot;a&#x3D;%d,b&#x3D;%d,c&#x3D;%d&quot;,1,2,3);

	push	3
	push	2
	push	1
	push	OFFSET $SG9695
	call	_printf
	add	esp, 16					; 00000010H

; 5    :     return 0; 

	xor	eax, eax

; 6    : &#125;

	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到<code>printf()</code>函数的参数是逆序存入栈中，第一个参数在最后入栈</p>
<p>在<code>32</code>位下，32位地址指针和int类型数据都占据<code>32位</code>即<code>4字节</code>的空间，因此4个参数总共占用<code>16</code>字节的存储空间</p>
<p>因此在调用函数之后，“ADD ESP, X”指令修正ESP寄存器中的栈指针。通常情况下，我们可以通过call之后的这条指令判断参数的数量：<code>变量总数＝*X*÷4。</code>(仅适用于调用约定为<code>cdecl</code>的程序)</p>
<p>如果某个程序连续地调用多个函数，且调用函数的指令之间不夹杂其他指令，那么编译器可能把释放参数存储空间的“ADD ESP,X”指令进行合并，一次性地释放所有空间</p>
<hr />
<p>体验用<code>onlydbg</code>加载这个程序</p>
<p>这里需要用到debug版本的编译命令</p>
<p><code>cl /Z7 /EHsc 1.exe 1.c</code>便于跟踪程序</p>
<p>找到<code>main</code>函数的方法:方法很多，不细说了</p>
<p>具体操作按书上来</p>
<h2 id="chap7-scanf"><a class="markdownIt-Anchor" href="#chap7-scanf"></a> Chap7 scanf()</h2>
<p>演示程序</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Enter X:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"You Entered: %d\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="x86-2"><a class="markdownIt-Anchor" href="#x86-2"></a> x86</h3>
<p><code>cl /FAs /Z7 2 2.c</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">_DATA	SEGMENT
$SG9696	DB	&#39;Enter X:&#39;, 0aH, 00H
	ORG $+2
$SG9697	DB	&#39;%d&#39;, 00H
	ORG $+1
$SG9698	DB	&#39;You Entered: %d&#39;, 0aH, 00H
_DATA	ENDS
_TEXT	SEGMENT
_x$ &#x3D; -4						; size &#x3D; 4
_main	PROC

; 3    : &#123;

	push	ebp
	mov	ebp, esp
	push	ecx

; 4    :     int x;
; 5    :     printf(&quot;Enter X:\n&quot;);

	push	OFFSET $SG9696
	call	_printf
	add	esp, 4

; 6    :     scanf(&quot;%d&quot;, &amp;x);

	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	push	OFFSET $SG9697
	call	_scanf
	add	esp, 8

; 7    : 
; 8    :     printf(&quot;You Entered: %d\n&quot;, x);

	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	push	OFFSET $SG9698
	call	_printf
	add	esp, 8

; 9    :     return 0;

	xor	eax, eax

; 10   : &#125;

	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>汇编解读:</p>
<ul>
<li>
<p>可以看到，<code>scanf()</code>传递的第二个参数(eax)是一个指向栈中的指针，x是局部变量，存储在栈中。在栈中分配了4字节空间，存储局部变量x</p>
</li>
<li>
<p>**汇编宏_x$ （其值为−4）**用于访问局部变量<em>x</em>，而EBP寄存器用来存储栈当前帧的指针。</p>
<p>在函数运行的期间，EBP一直指向当前的栈帧（stack frame）。这样，函数即可通过<strong>EBP+offset的方式访问本地变量、以及外部传入的函数参数</strong>。</p>
<p>ESP也可以用来访问本地变量，获取函数所需的运行参数。不过<strong>ESP的值经常发生变化，用起来并不方便</strong>。函数在启动之初就会利用EBP寄存器保存ESP寄存器的值。这就是为了确保在函数运行期间保证EBP寄存器存储的原始ESP值固定不变。</p>
<p>在32位系统里，典型的栈帧（stack frame）结构如下表所示。</p>
<table>
<thead>
<tr>
<th>……</th>
<th>……</th>
</tr>
</thead>
<tbody>
<tr>
<td>EBP-8</td>
<td>局部变量＃2，IDA标记为var_8</td>
</tr>
<tr>
<td>EBP-4</td>
<td>局部变量＃1，IDA标记为var_4</td>
</tr>
<tr>
<td>EBP</td>
<td>EBP的值</td>
</tr>
<tr>
<td>EBP+4</td>
<td>返回地址Return address</td>
</tr>
<tr>
<td>EBP+8</td>
<td>函数参数＃1，IDA标记为arg_0</td>
</tr>
<tr>
<td>EBP+0xC</td>
<td>函数参数＃2，IDA标记为arg_4</td>
</tr>
<tr>
<td>EBP+0x10</td>
<td>函数参数＃3，IDA标记为arg_8</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><code>scanf()</code>在此例中有两个参数,第一个参数是一个指针，指向含有&quot;%d&quot;的格式化字符串，第二个参数是局部变量<code>x</code>的地址</p>
<p>“lea eax, DWORD PTR _x$[ebp]”指令将变量<em>x</em>的地址放入EAX寄存器。</p>
<p>在此处<code>LEA</code>会将<code>EBP</code>寄存器值与宏_x$求和,然后将这个结果存储到<code>EAX</code>，然后把<code>EAX</code>寄存器的值送入栈中(就是把x的地址送入EAX寄存器)</p>
</li>
<li>
<p>而后调用<code>printf()</code>函数，第一个参数即格式化字符串的指针</p>
<p>第二个参数是<code>mov ecx,[ebp-4]</code>间接取值，传递给ecx的值是<code>ebp-4</code>指向的地址的值，即变量x的值</p>
</li>
</ul>
<hr />
<p>用<code>onlydbg</code>动态跟踪这个过程，具体书上有</p>
<ul>
<li>调试可以发现，执行完<code>scanf()</code>函数,<code>EAX</code>存储有函数的返回值，其值是<code>scanf()</code>读取参数的个数</li>
<li>我们可以在栈中找到局部变量的地址，进而跟踪其值</li>
</ul>
<h3 id="全局变量"><a class="markdownIt-Anchor" href="#全局变量"></a> 全局变量</h3>
<p>如果上文的<code>x</code>是全局变量,会有什么样的变化</p>
<p>将<code>x</code>改成全局变量</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">_DATA	SEGMENT
$SG9696	DB	&#39;Enter X:&#39;, 0aH, 00H
	ORG $+2
$SG9697	DB	&#39;%d&#39;, 00H
	ORG $+1
$SG9698	DB	&#39;You Entered: %d&#39;, 0aH, 00H
_DATA	ENDS
_TEXT	SEGMENT
_main	PROC

; 4    : &#123;

	push	ebp
	mov	ebp, esp

; 5    :    
; 6    :     printf(&quot;Enter X:\n&quot;);

	push	OFFSET $SG9696
	call	_printf
	add	esp, 4

; 7    :     scanf(&quot;%d&quot;, &amp;x);

	push	OFFSET _x
	push	OFFSET $SG9697
	call	_scanf
	add	esp, 8

; 8    : 
; 9    :     printf(&quot;You Entered: %d\n&quot;, x);

	mov	eax, DWORD PTR _x
	push	eax
	push	OFFSET $SG9698
	call	_printf
	add	esp, 8

; 10   :     return 0;

	xor	eax, eax

; 11   : &#125;

	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>
<p>可以发现<code>x</code>的存储空间不再由栈中存储,而是在数据段(由于没给x赋值，编译器自动优化为bss段(不占据空间))</p>
</li>
<li>
<p>如果对上述源代码稍做改动，加上变量初始化的指令：</p>
<pre class="line-numbers language-none"><code class="language-none">int x&#x3D;10; &#x2F;&#x2F;设置默认值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>那么对应的代码会变为：</p>
<pre class="line-numbers language-none"><code class="language-none">_DATA   SEGMENT
_x      DD      0aH
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>上述指令将初始化x。其中DD代表DWORD，表示<em>x</em>是32位的数据。</p>
<p>若在IDA里打开对x进行初始化的可执行文件，我们将会看到在数据段的开头部分看到初始化变量<em>x</em>。紧随其后的空间用于存储本例中的字符串。</p>
<p>用IDA打开7.2节里那个不初始化变量<em>x</em>的例子，那么将会看</p>
<p>有很多带“？”标记的变量，这是未初始化的<em>x</em>变量的标记。这意味着在程序加载到内存之后，操作系统将为这些变量分配空间、并填入数字零。但是在可执行文件里，这些未初始化的变量不占用内存空间。为了方便使用巨型数组之类的大型数据，人们刻意做了这种设定。</p>
</li>
</ul>
<h3 id="problem"><a class="markdownIt-Anchor" href="#problem"></a> Problem</h3>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">alter_string</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token function">strcpy</span> <span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">"Goodbye!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"Result: %s\n"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token function">alter_string</span> <span class="token punctuation">(</span><span class="token string">"Hello, world!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在<code>win</code>可运行，因为s是在data段</p>
<p>而在<code>linux</code>不可运行，s存储在<code>rodata</code>段，不可写</p>
<h2 id="chap8-参数获取"><a class="markdownIt-Anchor" href="#chap8-参数获取"></a> Chap8 参数获取</h2>
<p>main()函数把3个数字推送入栈，然后调用了f(int, int, int)。被调用方函数f()通过_a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mn>8</mn><mtext>一类的汇编宏访问所需参数以及函数自定义的局部变量。只不过从被调用方函数的数据栈的角度来看，外部参考的偏移量是正值，而局部变量的偏移量是负值。可见，当需要访问栈帧（</mtext><mi>s</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>f</mi><mi>r</mi><mi>a</mi><mi>m</mi><mi>e</mi><mtext>）以外的数据时，被调用方函数可把汇编宏（例</mtext><msub><mtext>如</mtext><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">=8一类的汇编宏访问所需参数以及函数自定义的局部变量。只不过从被调用方函数的数据栈的角度来看，外部参考的偏移量是正值，而局部变量的偏移量是负值。可见，当需要访问栈帧（stack frame）以外的数据时，被调用方函数可把汇编宏（例如_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">8</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">类</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">汇</span><span class="mord cjk_fallback">编</span><span class="mord cjk_fallback">宏</span><span class="mord cjk_fallback">访</span><span class="mord cjk_fallback">问</span><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">需</span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">及</span><span class="mord cjk_fallback">函</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">自</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">义</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">局</span><span class="mord cjk_fallback">部</span><span class="mord cjk_fallback">变</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">只</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">过</span><span class="mord cjk_fallback">从</span><span class="mord cjk_fallback">被</span><span class="mord cjk_fallback">调</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">函</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">栈</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">角</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">来</span><span class="mord cjk_fallback">看</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">外</span><span class="mord cjk_fallback">部</span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">考</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">偏</span><span class="mord cjk_fallback">移</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">正</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">而</span><span class="mord cjk_fallback">局</span><span class="mord cjk_fallback">部</span><span class="mord cjk_fallback">变</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">偏</span><span class="mord cjk_fallback">移</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">负</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">见</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">当</span><span class="mord cjk_fallback">需</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">访</span><span class="mord cjk_fallback">问</span><span class="mord cjk_fallback">栈</span><span class="mord cjk_fallback">帧</span><span class="mord cjk_fallback">（</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">）</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">外</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">被</span><span class="mord cjk_fallback">调</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">函</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">把</span><span class="mord cjk_fallback">汇</span><span class="mord cjk_fallback">编</span><span class="mord cjk_fallback">宏</span><span class="mord cjk_fallback">（</span><span class="mord cjk_fallback">例</span><span class="mord"><span class="mord cjk_fallback">如</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）与EBP寄存器的值相加，从而求得所需地址。</p>
<p>当变量<em>a</em>的值存入EAX寄存器之后，f()函数通过各参数的地址依次进行乘法和加法运算，运算结果一直存储于EAX寄存器。此后EAX的值就可以直接作为返回值传递给调用方函数。调用方函数main()再把EAX的值当作参数传递给printf()函数。</p>
<h2 id="chap9-返回值"><a class="markdownIt-Anchor" href="#chap9-返回值"></a> Chap9 返回值</h2>
<p>在<strong>x86系</strong>统里，被调用方函数通常通过EA<strong>X寄存器返回运算结果</strong>。若返回值属于byte或char类型数据，返回值将<strong>存储于EAX寄存器的低8位——AL寄存器存储返回值</strong>。如果<strong>返回值是浮点float型数据，那么返回值将存储在FPU的ST(0)寄存器</strong>里。ARM系统的情况相对简单一些，它通常使用R0寄存器回传返回值。</p>
<h3 id="void类型的返回值"><a class="markdownIt-Anchor" href="#void类型的返回值"></a> void类型的返回值</h3>
<p>调用<code>main</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">push envp
push argv
push argc
call main
push eax
call exit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也就是<code>exit(main(argc,argv,envp));</code></p>
<p>如果声明main()的数据类型是void，则main()函数不会明确返回任何值（没有return指令）。不过在main()函数退出时，EAX寄存器还会存有数据，EAX寄存器保存的数据会被传递给exit()函数、成为后者的输入参数。通常EAX寄存器的值会是被调用方函数残留的确定数据，所以void类型函数的返回值、也就是主函数退出代码往往属于伪随机数（pseudorandom）</p>
<h4 id="返回值为结构体型数据"><a class="markdownIt-Anchor" href="#返回值为结构体型数据"></a> 返回值为结构体型数据</h4>
<p>调用方函数（caller）创建了数据结构、分配了数据空间，被调用的函数仅向结构体填充数据。其效果等同于返回结构体。</p>
<h2 id="chap10-指针"><a class="markdownIt-Anchor" href="#chap10-指针"></a> Chap10 指针</h2>
<p>指针通常用来帮助函数处理返回值。当函数需要返回多个值时，它通常都是通过指针传递返回值的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">f1</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>sum<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>product<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
         <span class="token operator">*</span>sum<span class="token operator">=</span>x<span class="token operator">+</span>y<span class="token punctuation">;</span>
         <span class="token operator">*</span>product<span class="token operator">=</span>x<span class="token operator">*</span>y<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> sum<span class="token punctuation">,</span> product<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
         <span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">456</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>sum<span class="token punctuation">,</span> <span class="token operator">&amp;</span>product<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"sum=%d, product=%d\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">,</span> product<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">COMM     _product:DWORD
COMM     _sum:DWORD
; 定义字符串常量 $SG2803，表示格式化输出的字符串 &quot;sum&#x3D;%d, product&#x3D;%d\n&quot;
$SG2803 DB     &#39;sum&#x3D;%d, product&#x3D;%d&#39;, 0aH, 00H
; 定义参数在栈帧中的偏移量
_x$ &#x3D; 8             ; 参数 _x 在栈帧中的偏移量，大小为 4 字节
_y$ &#x3D; 12            ; 参数 _y 在栈帧中的偏移量，大小为 4 字节
_sum$ &#x3D; 16          ; _sum 在栈帧中的偏移量，大小为 4 字节
_product$ &#x3D; 20      ; _product 在栈帧中的偏移量，大小为 4 字节
; 定义 _f1 函数
_f1   PROC
      ; 将参数 _y 的值加载到 ecx 寄存器
      mov  ecx, DWORD PTR _y$[esp-4]
      ; 将参数 _x 的值加载到 eax 寄存器
      mov  eax, DWORD PTR _x$[esp-4]
      ; 计算 _x 和 _y 的和，结果存储到 edx 寄存器
      lea  edx, DWORD PTR [eax+ecx]
      ; 计算 _x 和 _y 的乘积，结果存储到 eax 寄存器
      imul eax, ecx;eax&#x3D;eax*ecx
      ; 将 _product 的地址加载到 ecx 寄存器
      mov  ecx, DWORD PTR _product$[esp-4]
      ; 保存 esi 寄存器的值，为后续操作做准备
      push esi
      ; 将 _sum 的地址加载到 esi 寄存器
      mov  esi, DWORD PTR _sum$[esp]
      ; 将和的结果存储到 _sum 指向的位置
      mov  DWORD PTR [esi], edx
      ; 将积的结果存储到 _product 指向的位置
      mov  DWORD PTR [ecx], eax
      ; 恢复 esi 寄存器的值
      pop  esi
      ; 返回到调用者
      ret  0
_f1   ENDP

; 定义 _main 函数
_main PROC
      ; 将 _product 的地址压入栈中
      push OFFSET _product
      ; 将 _sum 的地址压入栈中
      push OFFSET _sum
      ; 将参数 456 压入栈中
      push 456          ; 456 的十六进制表示为 0x1c8
      ; 将参数 123 压入栈中
      push 123          ; 123 的十六进制表示为 0x7b
      ; 调用 _f1 函数
      call _f1
      ; 将 _product 的值加载到 eax 寄存器
      mov  eax, DWORD PTR _product
      ; 将 _sum 的值加载到 ecx 寄存器
      mov  ecx, DWORD PTR _sum
      ; 将 _product 和 _sum 的值作为参数，调用 printf 函数
      push eax
      push ecx
      push OFFSET $SG2803
      call DWORD PTR __imp__printf
      ; 调整栈指针，清理参数
      add  esp, 28    
      xor  eax, eax
      ; 返回到调用者
      ret  0
_main ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="chap12-条件转移"><a class="markdownIt-Anchor" href="#chap12-条件转移"></a> Chap12 条件转移</h2>
<h3 id="数值比较"><a class="markdownIt-Anchor" href="#数值比较"></a> 数值比较</h3>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">f_signed</span> <span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">></span>b<span class="token punctuation">)</span>
          <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"a>b\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">==</span>b<span class="token punctuation">)</span>
          <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"a==b\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">&lt;</span>b<span class="token punctuation">)</span>
          <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"a&lt;b\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">f_unsigned</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">></span>b<span class="token punctuation">)</span>
          <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"a>b\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">==</span>b<span class="token punctuation">)</span>
          <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"a==b\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">&lt;</span>b<span class="token punctuation">)</span>
          <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"a&lt;b\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">&#123;</span>
    <span class="token function">f_signed</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">f_unsigned</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">_a$ &#x3D;  8  ; size  &#x3D; 4 
_b$ &#x3D; 12  ; size  &#x3D; 4 
_f_unsigned PROC
    push   ebp
    mov    ebp, esp
    mov    eax, DWORD PTR _a$[ebp]
    cmp    eax, DWORD PTR _b$[ebp]
    jbe    SHORT $LN3@f_unsigned
    push   OFFSET $SG2761    ; &#39;a&gt;b&#39;
    call   _printf
    add    esp, 4
$LN3@f_unsigned:
    mov    ecx, DWORD PTR _a$[ebp]
    cmp    ecx, DWORD PTR _b$[ebp]
    jne    SHORT $LN2@f_unsigned
    push   OFFSET $SG2763    ; &#39;a&#x3D;&#x3D;b&#39;
    call   _printf
    add    esp, 4
$LN2@f_unsigned:
    mov    edx, DWORD PTR _a$[ebp]
    cmp    edx, DWORD PTR _b$[ebp]
    jae    SHORT $LN4@f_unsigned
    push   OFFSET $SG2765    ; &#39;a&lt;b&#39;
    call   _printf
    add    esp, 4
LN4@f_unsigned:
    Pop   ebp
    Ret   0
_f_unsigned ENDP
_main   PROC
        push    ebp
        mov     ebp, esp
        push    2
        push    1
        call    _f_signed
        add     esp, 8
        push    2
        push    1
        call    _f_unsigned
        add     esp, 8
        xor     eax, eax
        pop     ebp
        ret     0
_main   ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>JLE，即“Jump if Less or Equal”。如果上一条CMP指令的第一个操作表达式小于或等于（不大于）第二个表达式，JLE将跳转到指令所标明的地址；如果不满足上述条件，则运行下一条指令，就本例而言程序将会调用printf()函数。第二个条件转移指令是JNE，“Jump if Not Equal”，如果上一条CMP的两个操作符不相等，则进行相应跳转。</li>
<li>JGE，即“Jump if Greater or Equal”。如果CMP的第一个表达式大于或等于第二个表达式（不小于），则进行跳转。这段程序里，如果三个跳转的判断条件都不满足，将不会调用printf()函数；不过，除非进行特殊干预，否则这种情况应该不会发生</li>
<li>经GCC编译后，f_unsigned()函数使用的条件转移指令是JBE（Jump if Below or Equal，相当于JLE）和JAE（Jump if Above or Equal，相当于JGE）。==JA/JAE/JB/JBE与JG/JGE/JL/JLE的区别，在于它们检查的标志位不同：前者检查借/进位标志位CF（1意味着小于）和零标志位ZF（1意味着相等），后者检查“SF XOR OF”（1意味着异号）和ZF。==从指令参数的角度看，<mark>前者适用于unsigned（无符号）类型数据的（CMP）运算，而后者的适用于signed（有符号）类型数据的运算。</mark></li>
</ul>
<h3 id="计算绝对值"><a class="markdownIt-Anchor" href="#计算绝对值"></a> 计算绝对值</h3>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">my_abs</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>
                 <span class="token keyword">return</span> <span class="token operator">-</span>i<span class="token punctuation">;</span>
         <span class="token keyword">else</span>
                 <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">i$ &#x3D; 8

my_abs   PROC
; ECX &#x3D; 输入值
         test    ecx, ecx          ; 执行 ECX 和自身的按位与操作以设置标志
; 检查输入值的符号
; 如果符号为正则跳过 NEG 指令
         jns     SHORT $LN2@my_abs ; 如果 ECX 为非负数，则跳转到 $LN2@my_abs
; 取反值
         neg     ecx               ; 如果 ECX 为负数，取反 ECX (ECX &#x3D; -ECX)
$LN2@my_abs:
; 将结果准备到 EAX:
       mov    eax,   ecx    ; 将 ECX 的值复制到 EAX
        ret     0                   ; 从过程返回（不清除任何参数）
my_abs  ENDP                        ; 过程 my_abs 的结束
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>neg</code> 指令用于将寄存器或内存位置中的操作数取反。具体来说，它将<mark>操作数变为它的相反数（即取负值）</mark>。<code>neg</code> 指令实际上是计算二补数。</p>
<p>以下是 <code>neg</code> 指令的详细解释：</p>
<ul>
<li>如果操作数是正数，<code>neg</code> 会将其变为负数。</li>
<li>如果操作数是负数，<code>neg</code> 会将其变为正数。</li>
<li>如果操作数是零，<code>neg</code> 会保持其为零。</li>
</ul>
<p>在处理过程中，<code>neg</code> 指令会影响标志寄存器（Flags Register）中的以下标志：</p>
<ul>
<li><strong>CF（进位标志）</strong>：如果结果为非零，则设置 CF。</li>
<li><strong>ZF（零标志）</strong>：如果结果为零，则设置 ZF。</li>
<li><strong>SF（符号标志）</strong>：根据结果的最高位设置 SF。</li>
<li><strong>OF（溢出标志）</strong>：如果操作数是最小的负数，则设置 OF（例如，对于32位整数，-2^31 变为 2^31-1 会导致溢出）。</li>
</ul>
<p>假设 <code>ECX</code> 寄存器包含值 <code>5</code> 或 <code>-5</code>，在执行 <code>neg</code> 指令后的变化如下：</p>
<pre class="line-numbers language-none"><code class="language-none">mov ecx, 5     ; ECX &#x3D; 5
neg ecx        ; ECX &#x3D; -5

mov ecx, -5    ; ECX &#x3D; -5
neg ecx        ; ECX &#x3D; 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="条件运算符"><a class="markdownIt-Anchor" href="#条件运算符"></a> 条件运算符</h3>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">f</span> <span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> a<span class="token operator">==</span><span class="token number">10</span> <span class="token operator">?</span> <span class="token string">"it is ten"</span> <span class="token operator">:</span> <span class="token string">"it is not ten"</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>
<p>在编译含有条件运算符的语句时，早期无优化功能的编译器会以编译“if/else”语句的方法进行处理。</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">$SG746   DB       &#39;it is ten&#39;, 00H         ; 定义字符串 &quot;it is ten&quot; 并以空字符结尾
$SG747   DB       &#39;it is not ten&#39;, 00H     ; 定义字符串 &quot;it is not ten&quot; 并以空字符结尾

tv65 &#x3D; -4 ; 这是一个临时变量，存储在栈帧中的偏移量为 -4
_a$ &#x3D; 8   ; 输入值在栈帧中的偏移量为 8

_f       PROC
         push     ebp                      ; 保存基指针 EBP
         mov      ebp, esp                 ; 设置新的栈帧
         push     ecx                      ; 保存 ECX 寄存器的值
; 比较输入值是否为10
         cmp      DWORD PTR _a$[ebp], 10   ; 比较位于栈帧偏移 _a$ 处的值是否为10
; 如果不等于10，则跳转到 $LN3@f
         jne      SHORT $LN3@f             ; 如果不等于10，跳转到 $LN3@f
; 将指向字符串 &#39;it is ten&#39; 的指针存储到临时变量中
         mov      DWORD PTR tv65[ebp], OFFSET $SG746 ; 将字符串 &quot;it is ten&quot; 的地址存储到 tv65 变量中
; 跳转到退出标签
         jmp      SHORT $LN4@f             ; 跳转到 $LN4@f
$LN3@f:
; 将指向字符串 &#39;it is not ten&#39; 的指针存储到临时变量中
         mov      DWORD PTR tv65[ebp], OFFSET $SG747 ; 将字符串 &quot;it is not ten&quot; 的地址存储到 tv65 变量中
$LN4@f:
; 这是退出部分。从临时变量中复制指向字符串的指针到 EAX 中
         mov      eax, DWORD PTR tv65[ebp] ; 将 tv65 变量中的值复制到 EAX 寄存器
         mov      esp, ebp                 ; 恢复栈指针
         pop      ebp                      ; 恢复基指针
         ret      0                        ; 返回，清理栈上的参数
_f       ENDP                              ; 过程 _f 结束
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>开启编译器优化</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">$SG792  DB       &#39;it is ten&#39;, 00H
$SG793  DB       &#39;it is not ten&#39;, 00H

_a$ &#x3D; 8 ; size &#x3D; 4
_f      PROC
; compare input value with 10
        cmp      DWORD PTR _a$[esp-4], 10
        mov      eax, OFFSET $SG792 ; &#39;it is ten&#39;
; jump to $LN4@f if equal
        je       SHORT $LN4@f
        mov      eax, OFFSET $SG793 ; &#39;it is not ten&#39;
$LN4@f:
        ret      0 
_f      ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h3 id="比较大小"><a class="markdownIt-Anchor" href="#比较大小"></a> 比较大小</h3>
<ul>
<li>启用优化功能后，编译器会尽可能避免使用条件转移指令</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">my_max</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">></span>b<span class="token punctuation">)</span>
                <span class="token keyword">return</span> a<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
                <span class="token keyword">return</span> b<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">my_min</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">&lt;</span>b<span class="token punctuation">)</span>
                <span class="token keyword">return</span> a<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
                <span class="token keyword">return</span> b<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>没开启优化</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">_a$ &#x3D; 8
_b$ &#x3D; 12
_my_min PROC
        push     ebp
        mov      ebp, esp
        mov      eax, DWORD PTR _a$[ebp]
; compare A and B:
        cmp      eax, DWORD PTR _b$[ebp]
; jump, if A is greater or equal to B:
        jge      SHORT $LN2@my_min
; reload A to EAX if otherwise and jump to exit
        mov      eax, DWORD PTR _a$[ebp]
        jmp      SHORT $LN3@my_min
        jmp      SHORT $LN3@my_min ; this is redundant JMP
$LN2@my_min:
; return B
        mov      eax, DWORD PTR _b$[ebp]
$LN3@my_min:
        pop      ebp
        ret      0
_my_min ENDP

_a$ &#x3D; 8
_b$ &#x3D; 12
_my_max PROC
        push     ebp
        mov      ebp, esp
        mov      eax, DWORD PTR _a$[ebp]
; compare A and B:
        cmp      eax, DWORD PTR _b$[ebp]
; jump if A is less or equal to B:
        jle      SHORT $LN2@my_max
; reload A to EAX if otherwise and jump to exit
        mov      eax, DWORD PTR _a$[ebp]
        jmp      SHORT $LN3@my_max
        jmp      SHORT $LN3@my_max ; this is redundant JMP
$LN2@my_max:
; return B
        mov      eax, DWORD PTR _b$[ebp]
$LN3@my_max:
        pop      ebp
        ret      0
_my_max ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="chap13-switch"><a class="markdownIt-Anchor" href="#chap13-switch"></a> Chap13 Switch</h2>
<h3 id="case较少的情形"><a class="markdownIt-Anchor" href="#case较少的情形"></a> case较少的情形</h3>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">f</span> <span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
    <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span> <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"zero\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span> <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"one\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span> <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"two\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token operator">:</span> <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"something unknown\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//test</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>msvs不开启优化</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">tv64 &#x3D; -4 ; size &#x3D; 4
_a$ &#x3D; 8   ; size &#x3D; 4
_f     PROC
    push   ebp
    mov    ebp, esp
    push   ecx
    mov    eax, DWORD PTR _a$[ebp]
    mov    DWORD PTR tv64[ebp], eax
    cmp    DWORD PTR tv64[ebp], 0
    je     SHORT $LN4@f 
    cmp    DWORD PTR tv64[ebp], 1
    je     SHORT $LN3@f
    cmp    DWORD PTR tv64[ebp], 2
    je     SHORT $LN2@f
    jmp    SHORT $LN1@f
$LN4@f:0
    push   OFFSET $SG739 ; &#39;zero&#39;, 0aH, 00H
    call   _printf
    add    esp, 4
    jmp    SHORT $LN7@f
$LN3@f:1
    push   OFFSET $SG741 ; &#39;one&#39;, 0aH, 00H
    call   _printf
    add    esp, 4
    jmp    SHORT $LN7@f
$LN2@f:2
    push   OFFSET $SG743 ; &#39;two&#39;, 0aH, 00H
    call   _printf
    add    esp, 4
    jmp    SHORT $LN7@f
$LN1@f:default
    push   OFFSET $SG745 ; &#39;something unknown&#39;, 0aH, 00H
    call   _printf
    add    esp, 4
$LN7@f:ret
    mov    esp, ebp
    pop    ebp
    ret    0 
_f     ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以发现编译器把Switch翻译成了if else形式可以认为，switch()语句是一种旨在简化大量嵌套if()语句而设计的语法糖</p>
<p><mark>开启优化</mark></p>
<p><code>cl 1.c /Fa1.asm /Ox</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">_a$ &#x3D; 8 ; size &#x3D; 4
_f     PROC
    mov    eax, DWORD PTR _a$[esp-4];eax&#x3D;a
    sub    eax, 0;eax&#x3D;eax-0 
    je     SHORT $LN4@f;if a&#x3D;&#x3D;0
    sub    eax, 1
    je     SHORT $LN3@f;if a&#x3D;&#x3D;1
    sub    eax, 1
    je     SHORT $LN2@f;if a&#x3D;&#x3D;2
    ;default
    mov    DWORD PTR _a$[esp-4], OFFSET $SG791 ; &#39;something unknown&#39;, 0aH, 00H
    jmp    _printf
$LN2@f:;2
    mov    DWORD PTR _a$[esp-4], OFFSET $SG789 ; &#39;two&#39;, 0aH, 00H
    jmp    _printf
$LN3@f:;1
    mov    DWORD PTR _a$[esp-4], OFFSET $SG787 ; &#39;one&#39;, 0aH, 00H
    jmp    _printf
$LN4@f:;0
    mov    DWORD PTR _a$[esp-4], OFFSET $SG785 ; &#39;zero&#39;, 0aH, 00H
    jmp    _printf
_f     ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>两处不同</p>
<ul>
<li>
<p>a存到eax之后，eax-0；这样看似无意义,实际上可以检查eax寄存器的值是否为0,如果eax是0，ZF=1,进而检查第一个判断条件,如果不是就继续-1判断</p>
</li>
<li>
<p>在把字符串指针存储到变量<em>a</em>之后，函数使用JMP指令调用printf()函数。</p>
<p>这点不难解释：调<mark>用方函数把参数推送入栈之后，的确通常通过CALL指令调用其他函数。这种情况下，CALL指令会把返回地址推送入栈、并通过无条件转移的手段启用被调用方函数</mark>。就本例而言，在被调用方函数运行的任意时刻，栈的内存存储结构为：</p>
<ul>
<li>ESP——指向RA。</li>
<li>ESP＋4——指向变量<em>a</em>。</li>
</ul>
<p>另一方面，在本例程序调用printf()函数之前、之后，<mark>除了制各第一个格式化字符串的参数问题以外，栈的存储结构其实没有发生变化</mark>。所以，编译器在分配JMP指令之前，把字符串指针存储到相应地址上。</p>
<p>这个程序把<mark>函数的第一个参数替换为字符串的指针</mark>，然后跳转到printf()函数的地址，就好像程序没有“调用”过f()函数、直接“转移”了printf()函数一般。当printf()函数完成输出的使命以后，它会执行RET返回指令。RET指令会从栈中读取（POP）返回地址RA、并跳转到RA。不过<mark>这个RA不是其调用方函数——f()函数内的某个地址，而是调用f()函数的函数即main()函数的某个地址</mark>。换而言之，==跳转到这个RA地址后，printf()函数会伴随其调用方函数f()==一同结束。</p>
<p>除非每个case从句的最后一条指令都是调用printf()函数，否则编译器就做不到这种程度的优化。某种意义上说这与longjmp()函数十分相似。当然，这种优化的目的无非就是提高程序的运行速度。</p>
</li>
</ul>
<h3 id="case较多的情形"><a class="markdownIt-Anchor" href="#case较多的情形"></a> case较多的情形</h3>
<p>在switch()语句存在大量case()分支的情况下，编译器就不能直接套用大量JE/JNE指令了。会生成一种跳转表,否则程序代码肯定会非常庞大。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">f</span> <span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
    <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span> <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"zero\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span> <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"one\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span> <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"two\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span> <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"three\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token number">4</span><span class="token operator">:</span> <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"four\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token operator">:</span> <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"something unknown\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// test</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>x86,未开启优化,msvs</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">tv64 &#x3D; -4    ; size&#x3D;4 
_a$  &#x3D;  8    ; size &#x3D; 4
_f     PROC
     push   ebp
     mov    ebp, esp;函数序言
     push   ecx
     mov    eax, DWORD PTR _a$[ebp];eax&#x3D;a
     mov    DWORD PTR tv64[ebp], eax;tv64&#x3D;a
     cmp    DWORD PTR tv64[ebp], 4;if a&#x3D;&#x3D;4
     ja     SHORT $LN1@f;if a&gt;4
     mov    ecx, DWORD PTR tv64[ebp]
     jmp    DWORD PTR $LN11@f[ecx*4];jmp 跳转表
$LN6@f:0
     push   OFFSET $SG739 ; &#39;zero&#39;, 0aH, 00H
     call   _printf
     add    esp, 4
     jmp    SHORT $LN9@f
$LN5@f:1
     push   OFFSET $SG741 ; &#39;one&#39;, 0aH, 00H
     call   _printf
     add    esp, 4
     jmp    SHORT $LN9@f
$LN4@f:2
     push   OFFSET $SG743 ; &#39;two&#39;, 0aH, 00H
     call   _printf
     add    esp, 4
     jmp    SHORT $LN9@f
$LN3@f:3
     push   OFFSET $SG745 ; &#39;three&#39;, 0aH, 00H
     call   _printf
     add    esp, 4
     jmp    SHORT $LN9@f
$LN2@f:4
     push   OFFSET $SG747 ; &#39;four&#39;, 0aH, 00H
     call   _printf
     add    esp, 4
     jmp    SHORT $LN9@f
$LN1@f:defalut
     push   OFFSET $SG749 ; &#39;something unknown&#39;, 0aH, 00H
     call   _printf
     add    esp, 4
$LN9@f:;ret
     mov    esp, ebp
     pop    ebp
     ret    0
     npad    2; align next label
$LN11@f:;跳转表
     DD    $LN6@f ; 0
     DD    $LN5@f ; 1
     DD    $LN4@f ; 2
     DD    $LN3@f ; 3
     DD    $LN2@f ; 4
_f     ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>
<p>汇编解读:</p>
<ul>
<li>
<p>这段代码可被分为数个调用<code>printf()</code>函数的指令组</p>
</li>
<li>
<p>$ln11@F的偏移量开始的表叫做跳转表(jumptable)</p>
</li>
<li>
<p>函数最初把变量a与数字4进行比较，如果a&gt;4，就打印something unknown</p>
</li>
<li>
<p><code>jmp    DWORD PTR $LN11@f[ecx*4]</code>如果a&lt;=4，会先计算a*4,然后根据LN11@f这个表查询，并跳转到这个表所指向的地址。<mark>为什么要x4?是因为x86系统的内存地址都是32位数据，每个地址占用4字节，偏移地址需要x4才能到达</mark></p>
<p>此时的switch语句等效于<code>jmp DWORD PTR ($LN11@f[ecx*4])$LN11@f+ecx*4</code></p>
</li>
<li>
<p>npad指令属于<code>汇编宏</code>，==它的作用是把紧接其后的标签地址向4字节（或16字节）边界对齐。==npad的地址对齐功能可<code>提高处理器的IO读写效率</code>，通过一次操作即可完成内存总线、缓冲内存等设备的数据操作。</p>
</li>
</ul>
</li>
</ul>
<p>switch()的大体框架</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">MOV REG,input
CMP REG,4 ; maximal number of cases
JA default 
SHL REG,3 ; find element in table.shift for 3bits in x64.
MOV REG, jump_table[REG]
JMP REG

case1;
     ; do something
     JMP exit
case2;
     ; do something
     JMP exit
case3;
     ; do something
     JMP exit
case4;
     ; do something
     JMP exit
Case5;
     ; do something
     JMP exit

defaule:

     …

exit:

     …

jump_table dd casel
           dd case2
           dd case3
           dd case4
           dd case5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>若不使用上述指令，我们也可以<mark>在32位系统上使用指令JMP jump_table[REG*4]</mark>/在<mark>64位上使用JMP jump_table[REG*8]</mark>，实现转移表中的寻址计算。</p>
<p>说到底，转移表只不过是某种指针数组它和18.5节介绍的那种指针数组十分雷同。</p>
<h3 id="case从句多对一"><a class="markdownIt-Anchor" href="#case从句多对一"></a> case从句多对一</h3>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">f</span> <span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
         <span class="token keyword">switch</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span>
         <span class="token punctuation">&#123;</span>
         <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>
         <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>
         <span class="token keyword">case</span> <span class="token number">7</span><span class="token operator">:</span>
         <span class="token keyword">case</span> <span class="token number">10</span><span class="token operator">:</span>
                  <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"1, 2, 7, 10\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token keyword">break</span><span class="token punctuation">;</span>
         <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>
         <span class="token keyword">case</span> <span class="token number">4</span><span class="token operator">:</span>
         <span class="token keyword">case</span> <span class="token number">5</span><span class="token operator">:</span>
         <span class="token keyword">case</span> <span class="token number">6</span><span class="token operator">:</span>
                  <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"3, 4, 5\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token keyword">break</span><span class="token punctuation">;</span>
         <span class="token keyword">case</span> <span class="token number">8</span><span class="token operator">:</span>
         <span class="token keyword">case</span> <span class="token number">9</span><span class="token operator">:</span>
         <span class="token keyword">case</span> <span class="token number">20</span><span class="token operator">:</span>
         <span class="token keyword">case</span> <span class="token number">21</span><span class="token operator">:</span>
                  <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"8 9, 21\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token keyword">break</span><span class="token punctuation">;</span>
         <span class="token keyword">case</span> <span class="token number">22</span><span class="token operator">:</span>
                  <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"22\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token keyword">break</span><span class="token punctuation">;</span>
         <span class="token keyword">default</span><span class="token operator">:</span>
                  <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"default\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token keyword">break</span><span class="token punctuation">;</span>
         <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">&#123;</span>
         <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果编译器刻板地按照每种可能的逻辑分支逐一分配对应的指令组，那么程序里将会存在大量的重复指令。一般而言，编译器会通过某种<mark>派发机制</mark>来降低代码的冗余度。</p>
<p>使用MSVS 开启/Ox优化</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly"> 1 $SG2798 DB        &#39;1, 2, 7, 10&#39;, 0aH, 00H
 2 $SG2800 DB        &#39;3, 4, 5&#39;, 0aH, 00H
 3 $SG2802 DB        &#39;8, 9, 21&#39;, 0aH, 00H
 4 $SG2804 DB        &#39;22&#39;, 0aH, 00H
 5 $SG2806 DB        &#39;default&#39;, 0aH, 00H
 6
 7 _a$ &#x3D; 8
 8 _f      PROC
 9         mov       eax, DWORD PTR _a$[esp-4]
10         dec       eax
11         cmp       eax, 21
12         ja        SHORT $LN1@f
13         movzx     eax, BYTE PTR $LN10@f[eax];从eax寄存器指向的内存地址中读取一个字节（BYTE）大小的数据，然后无符号扩展这个字节到32位（DWORD），最后将扩展后的结果存储到eax寄存器中。
14         jmp       DWORD PTR $LN11@f[eax*4]
15 $LN5@f:
16         mov       DWORD PTR _a$[esp-4], OFFSET $SG2798 ; &#39;1, 2, 7, 10&#39;
17         jmp       DWORD PTR __imp__printf
18 $LN4@f:
19         mov       DWORD PTR _a$[esp-4], OFFSET $SG2800 ; &#39;3, 4, 5&#39;
20         jmp       DWORD PTR __imp__printf
21 $LN3@f:
22         mov       DWORD PTR _a$[esp-4], OFFSET $SG2802 ; &#39;8, 9, 21&#39;
23         jmp       DWORD PTR __imp__printf
24 $LN2@f:
25         mov       DWORD PTR _a$[esp-4], OFFSET $SG2804 ; &#39;22&#39;
26         jmp       DWORD PTR __imp__printf
27 $LN1@f:
28         mov       DWORD PTR _a$[esp-4], OFFSET $SG2806 ; &#39;default&#39;
29         jmp       DWORD PTR __imp__printf
30         npad      2 ; align $LN11@f table on 16-byte boundary
31 $LN11@f:
32         DD        $LN5@f ; print &#39;1, 2, 7, 10&#39;
33         DD        $LN4@f ; print &#39;3, 4, 5&#39;
34         DD        $LN3@f ; print &#39;8, 9, 21&#39;
35         DD        $LN2@f ; print &#39;22&#39;
36         DD        $LN1@f ; print &#39;default&#39;
37 $LN10@f:
38         DB        0 ; a&#x3D;1  ;byte型1个字节
39         DB        0 ; a&#x3D;2
40         DB        1 ; a&#x3D;3
41         DB        1 ; a&#x3D;4
42         DB        1 ; a&#x3D;5
43         DB        1 ; a&#x3D;6
44         DB        0 ; a&#x3D;7
45         DB        2 ; a&#x3D;8
46         DB        2 ; a&#x3D;9
47         DB        0 ; a&#x3D;10
48         DB        4 ; a&#x3D;11
49         DB        4 ; a&#x3D;12
50         DB        4 ; a&#x3D;13
51         DB        4 ; a&#x3D;14
52         DB        4 ; a&#x3D;15
53         DB        4 ; a&#x3D;16
54         DB        4 ; a&#x3D;17
55         DB        4 ; a&#x3D;18
56         DB        4 ; a&#x3D;19
57         DB        2 ; a&#x3D;20
58         DB        2 ; a&#x3D;21
59         DB        3 ; a&#x3D;22
60 _f      ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>汇编解读:</p>
<ul>
<li>
<p>这里使用了两个表，一个是索引表$LN10@f,另一个转移表是$LN11@f</p>
</li>
<li>
<p><code>movzx</code> 是汇编语言中的一个指令，它是 <code>move with zero extend</code> 的缩写，用于无符号扩展并传送数据。此指令主要用于将一个较小位宽的数据（通常是8位或16位）加载到一个较大位宽的寄存器或内存位置中，并在<mark>扩展高位时用0填充。</mark></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">1mov bl, 80h   ; 将8位立即数80h送入8位寄存器BL
2movzx ax, bl  ; 将BL的内容无符号扩展到16位，并放入AX寄存器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在这个例子中，<code>BL</code> 寄存器中的值是 <code>80h</code>（十进制128），当使用 <code>movzx</code> 指令将 <code>BL</code> 的内容复制到 <code>AX</code> 寄存器时，因为是无符号扩展，所以 <code>BL</code> 的值被扩展为 <code>0080h</code>（前导的高位补0），这样 <code>AX</code> 寄存器的值就变成了 <code>0080h</code>。</p>
</li>
<li>
<p>首先movzx指令在索引表中查询输入值,返回0(input1,2,7,10);1(input3,4,5),2(input8,9,21),3(input 22)4(default)</p>
</li>
<li>
<p>然后把缩影表的返回值，在第二个转移表中完成跳转s</p>
</li>
</ul>
<hr />
<h3 id="fall-through"><a class="markdownIt-Anchor" href="#fall-through"></a> fall-through</h3>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"> <span class="token number">1</span> #define R <span class="token number">1</span>
 <span class="token number">2</span> #define W <span class="token number">2</span>
 <span class="token number">3</span> #define RW <span class="token number">3</span>
 <span class="token number">4</span>
 <span class="token number">5</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> type<span class="token punctuation">)</span>
 <span class="token number">6</span> <span class="token punctuation">&#123;</span>
 <span class="token number">7</span>          <span class="token keyword">int</span> read<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> write<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token number">8</span>
 <span class="token number">9</span>          <span class="token keyword">switch</span> <span class="token punctuation">(</span>type<span class="token punctuation">)</span>
<span class="token number">10</span>          <span class="token punctuation">&#123;</span>
<span class="token number">11</span>          <span class="token keyword">case</span> RW<span class="token operator">:</span>
<span class="token number">12</span>                   read<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token number">13</span>          <span class="token keyword">case</span> W<span class="token operator">:</span>
<span class="token number">14</span>                   write<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token number">15</span>                   <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token number">16</span>          <span class="token keyword">case</span> R<span class="token operator">:</span>
<span class="token number">17</span>                   read<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token number">18</span>                   <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token number">19</span>          <span class="token keyword">default</span><span class="token operator">:</span>
<span class="token number">20</span>                   <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token number">21</span>          <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token number">22</span>          <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"read=%d, write=%d\n"</span><span class="token punctuation">,</span> read<span class="token punctuation">,</span> write<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">23</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>无论type的值是RW还是W，程序都会执行第14行的指令。type为RW的陈述语句里没有break指令，从而利用switch语句的fall through效应。</p>
<p>msvs x86 assembly</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">$SG1305 DB       &#39;read&#x3D;%d, write&#x3D;%d&#39;, 0aH, 00H

_write$ &#x3D; -12    ; size&#x3D; 4
_read$  &#x3D; -8     ; size&#x3D; 4
tv64  &#x3D; -4       ; size&#x3D; 4
_type$  &#x3D; 8      ; size&#x3D; 4
_f        PROC
          push   ebp
          mov    ebp, esp
          sub    esp, 12;int write,read,tv64
          mov    DWORD PTR _read$[ebp], 0;read&#x3D;0
          mov    DWORD PTR _write$[ebp], 0;write&#x3D;0
          mov    eax, DWORD PTR _type$[ebp];eax&#x3D;type
          mov    DWORD PTR tv64[ebp], eax;tv64&#x3D;type
          cmp    DWORD PTR tv64[ebp], 1 ; R
          je     SHORT $LN2@f
          cmp    DWORD PTR tv64[ebp], 2 ; W
          je     SHORT $LN3@f;无break语句
          cmp    DWORD PTR tv64[ebp], 3 ; RW
          je     SHORT $LN4@f
          jmp    SHORT $LN5@f;break
$LN4@f: ; case RW:
          mov    DWORD PTR _read$[ebp], 1
$LN3@f: ; case W:
          mov    DWORD PTR _write$[ebp], 1
          jmp    SHORT $LN5@f
$LN2@f: ; case R:
          mov    DWORD PTR _read$[ebp], 1
$LN5@f: ;printf
          mov    ecx, DWORD PTR _write$[ebp]
          push   ecx
          mov    edx, DWORD PTR _read$[ebp]
          push   edx
          push   OFFSET $SG1305 ; &#39;read&#x3D;%d, write&#x3D;%d&#39;
          call   _printf
          add    esp, 12
          mov    esp, ebp
          pop    ebp
          ret    0
_f        ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="chap14-循环"><a class="markdownIt-Anchor" href="#chap14-循环"></a> Chap14 循环</h2>
<p>x86指令集里有一条专门的LOOP指令。<mark>LOOP指令检测ECX寄存器的值是否是0，如果它不是0则将其递减，并将操作权交给操作符所指定的标签处（即跳转）</mark>。或许是因为循环指令过于复杂的缘故，至今尚未见过直接使用LOOP指令将循环语句转译成汇编语句的编译器。所以，如果<mark>哪个程序直接使用LOOP指令进行循环控制，那它很可能就是手写的汇编程序。</mark></p>
<h3 id="for"><a class="markdownIt-Anchor" href="#for"></a> for</h3>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">printing_function</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"f(%d)\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> i<span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
                <span class="token function">printing_function</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">_i$ &#x3D; -4 
_main   PROC
    push   ebp
    mov    ebp, esp
    push   ecx
    mov    DWORD PTR _i$[ebp], 2     ; 初始态;i&#x3D;2
    jmp    SHORT $LN3@main
$LN2@main:
    mov    eax, DWORD PTR _i$[ebp]     ; 循环控制语句：
    add    eax, 1                      ; i递增1
    mov    DWORD PTR _i$[ebp], eax
$LN3@main:
    cmp    DWORD PTR _i$[ebp], 10      ; 判断是否满足循环条件 if i&#x3D;&#x3D;10
    jge    SHORT $LN1@main             ; 如果i&#x3D;10 则终止循环语句
    mov    ecx, DWORD PTR _i$[ebp]     ; 循环体: call f(i)
    push   ecx;传参
    call   _printing_function
    add    esp, 4
    jmp    SHORT $LN2@main             ; 跳到循环开始处
$LN1@main: ;exit                            ; 循环结束
    xor    eax, eax
    mov    esp, ebp
    pop    ebp
    ret     0
_main    ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr />
<p>gcc</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">main            proc near    ; 开始定义主程序过程

var_20          &#x3D; dword    ptr -20h  ; 定义一个变量var_20，在栈上距离EBP-20h的位置
var_4           &#x3D; dword    ptr –4     ; 定义另一个变量var_4，在栈上距离EBP-4的位置

                push       ebp         ; 保存当前基址指针（EBP）
                mov        ebp, esp    ; 将栈顶指针（ESP）复制到基址指针（EBP），建立新的堆栈帧
                and        esp, 0FFFFFFF0h ; 确保ESP为16字节对齐，通过与操作去掉ESP的低4位
                sub        esp, 20h    ; 在栈上为局部变量分配空间，减小ESP 32字节(20h)

                mov        [esp+20h+var_4], 2 ; 初始化变量var_4，即(i&#x3D;2)，这里存的是循环起始值
                jmp        short loc_8048476 ; 无条件跳转到循环条件检查处开始循环

loc_8048465:                  ; 循环体开始
                mov        eax, [esp+20h+var_4] ; 把计数器(i)的值加载到EAX寄存器
                mov        [esp+20h+var_20], eax ; 把EAX的值（即i的值）存入var_20，可能是为调用准备参数
                call       printing_function ; 调用打印函数，可能打印var_20中的值
                add        [esp+20h+var_4], 1 ; 将计数器(i)加1，即i&#x3D;i+1

loc_8048476:                  ; 循环条件检查
                cmp        [esp+20h+var_4], 9 ; 比较计数器(i)是否小于等于9
                jle        short loc_8048465 ; 如果i&lt;&#x3D;9，则跳转回循环体继续执行

                mov        eax, 0      ; 设置返回值为0，这里作为程序正常退出的标志
                leave                   ; 恢复先前的堆栈状态，将ESP设置回EBP的值，然后弹出EBP
                retn                    ; 返回调用者，结束程序

main            endp             ; 结束主程序过程定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr />
<p>msvs开启优化</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">_main    PROC
     push   esi
     mov    esi, 2
$LL3@main:
     push   esi
     call   _printing_function
     inc    esi
     add    esp, 4
     cmp    esi, 10     ; 0000000aH
     jl     SHORT $LL3@main
     xor    eax, eax
     pop    esi
     ret    0
_main    ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>开启优化后，<code>ESI</code>寄存器成了计数器<code>i</code>的专用寄存器,大幅简洁了汇编s</p>
<p><mark>进行这种优化的前提条件是：被调用方函数不应当修改局部变量专用寄存器的值。当然，在本例中编译器能够判断函数printing_function ()不会修改ESI寄存器的值。在编译器决定给局部变量分配专用寄存器的时候，它会在函数序言部分保存这些专用寄存器的初始状态，然后在函数尾声里还原这些寄存器的原始值，因此存在<code>push esi</code>和<code>pop esi</code>来还原原始值</mark></p>
<hr />
<p><code>gcc -O3 -o 1 1,c</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">main            proc near

var_10          &#x3D; dword ptr -10h

                push    ebp
                mov     ebp, esp
                and     esp, 0FFFFFFF0h
                sub     esp, 10h
                mov     [esp+10h+var_10], 2
                call    printing_function
                mov     [esp+10h+var_10], 3
                call    printing_function
                mov     [esp+10h+var_10], 4
                call    printing_function
                mov     [esp+10h+var_10], 5
                call    printing_function
                mov     [esp+10h+var_10], 6
                call    printing_function
                mov     [esp+10h+var_10], 7
                call    printing_function
                mov     [esp+10h+var_10], 8
                call    printing_function
                mov     [esp+10h+var_10], 9
                call    printing_function
                xor     eax, eax
                leave
                retn
main            endp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>
<p>在这里，gcc把循环指令给分解了(就是给展开了)</p>
<p>编译器会对<mark>迭代次数较少的循环进行循环分解</mark>（Loop unwinding）对处理。展开循环体以后代码的执行效率会有所提升，但是会增加程序代码的体积。</p>
</li>
<li>
<p><mark>如果迭代次数多的话，gcc的优化代码就与msvs相差无几</mark></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">                public main
main            proc near

var_20          &#x3D; dword    ptr -20h

                push       ebp
                mov        ebp, esp
                and        esp, 0FFFFFFF0h
                push       ebx
                mov        ebx, 2 ; i&#x3D;2
                sub        esp, 1Ch

; aligning label loc_80484D0 (loop body begin) by 16-byte border:
                nop
loc_80484D0:
; pass (i) as first argument to printing_function():
                mov        [esp+20h+var_20], ebx
                add        ebx, 1 ; i++
                call       printing_function
                cmp        ebx, 64h ; i&#x3D;&#x3D;100?
                jnz        short loc_80484D0 ; if not, continue
                add        esp, 1Ch
                xor        eax, eax ; return 0
                pop        ebx
                mov        esp, ebp
                pop        ebp
                retn
main            endp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>区别在于gcc是拿ebx作为i的专有寄存器，其他与msvs类似</p>
</li>
</ul>
<hr />
<h3 id="内存块复制"><a class="markdownIt-Anchor" href="#内存块复制"></a> 内存块复制</h3>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">my_memcpy</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span> dst<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span> src<span class="token punctuation">,</span> <span class="token class-name">size_t</span> cnt<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
         <span class="token class-name">size_t</span> i<span class="token punctuation">;</span>
         <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>cnt<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
                  dst<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>src<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr />
<p><code>gcc -Os</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; RDI &#x3D; 目标地址;dst
; RSI &#x3D; 源地址;src
; RDX &#x3D; 块大小;cnt

; 在 0 的位置初始化计数器（i）
xor     eax, eax   
 
.L2:    
; 如果所有字节已复制，则退出：
cmp     rax, rdx   ; 对寄存器rax和rdx的值进行比较。   
je      .L5    ; 如果这两个值相等（即已经拷贝了规定的字节数），就跳转到.L5，即返回（ret）。

; 在 RSI+i 处加载字节：
mov     cl, BYTE PTR [rsi+rax]   ; 将地址为（rsi+rax）的一个字节值加载到cl寄存器中。

; 在 RDI+i 处存储字节：
mov     BYTE PTR [rdi+rax], cl   ; 将cl寄存器的值存储到地址为（rdi+rax）的内存中。

inc     rax   ; i++，将rax寄存器的值增加1，以便下一次复制下一个字节。
jmp     .L2   ; 无条件跳转到.L2，进行下一轮的比较和字节拷贝。

.L5:
ret    ; 函数返回，结束拷贝操作。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">    MOV [counter], 2 ; initialization
    JMP label_check
label_increment:
    ADD [counter], 1 ; increment
label_check:
    CMP [counter], 10
    JGE exit
    ; loop body
    ; do something here
    ; use counter variable in local stack
    JMP label_increment
exit:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通常情况下，程序应当首先判断循环条件是否满足，然后再执行循环体。但是在编译器确定第一次迭代肯定会发生的情况下，它可能会调换循环体和判断语句的顺序。下面这个程序就是个典型的例子。</p>
<p>指令清单14.19　x86</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">    MOV REG, 2 ; initialization
body:
    ; loop body
    ; do something here
    ; use counter in REG, but do not modify it!
    INC REG ; increment
    CMP REG, 10
    JL body<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译器不会使用LOOP指令。由LOOP控制的循环控制语句比较少见。如果某段代码带有LOOP指令，那么您应当认为这是手写出来的汇编程序。</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">    ; count from 10 to 1
    MOV ECX, 10
body:
    ; loop body
    ; do something here
    ; use counter in ECX, but do not modify it!
    LOOP body<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>ECX</code>作为count的专用寄存器</p>
<h3 id="problem-2"><a class="markdownIt-Anchor" href="#problem-2"></a> Problem</h3>
<ol>
<li></li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>i<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="4">
<li></li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">100</span><span class="token punctuation">;</span>i<span class="token operator">+=</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="chap15-c语言字符串的函数"><a class="markdownIt-Anchor" href="#chap15-c语言字符串的函数"></a> Chap15 C语言字符串的函数</h2>
<h3 id="strlen"><a class="markdownIt-Anchor" href="#strlen"></a> strlen()</h3>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">my_strlen</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> str<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>eos<span class="token operator">=</span>str<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">*</span>eos<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">(</span>eos<span class="token operator">-</span>str<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">my_strlen</span><span class="token punctuation">(</span><span class="token string">"hello!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr />
<p><code>Non-optimizing MSVS</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">_eos$ &#x3D; -4                            ; 定义局部变量eos的栈偏移量为-4
_str$ &#x3D; 8                             ; 定义参数str的栈偏移量为8
_strlen PROC
    push    ebp                       ; 保存基址指针
    mov     ebp, esp                  ; 设置新的基址指针
    push    ecx                       ; 保存ecx寄存器的值
    mov     eax, DWORD PTR _str$[ebp] ; 将传入的字符串指针存储到eax中
    mov     DWORD PTR _eos$[ebp], eax ; 将eax的值（即字符串指针）保存到局部变量eos 中
$LN2@strlen_:
    mov     ecx, DWORD PTR _eos$[ebp] ; 将eos的值加载到ecx中

    ; 从ecx指向的地址处取8位字节，并将其作为32位值（带符号扩展）加载到edx中
    movsx   edx, BYTE PTR [ecx];edx&#x3D;*eos
    mov     eax, DWORD PTR _eos$[ebp] ; 将eos的值加载到eax中
    add     eax, 1                    ; 将eax自增1，指向下一个字符
    mov     DWORD PTR _eos$[ebp], eax ; 将更新后的eax值保存回eos中
    test    edx, edx                  ; 测试edx寄存器（即当前字符是否为0）
    je      SHORT $LN1@strlen_        ; 如果edx为0，跳转到$LN1@strlen_，结束循环
    jmp     SHORT $LN2@strlen_        ; 否则，继续循环

$LN1@strlen_:
    ; 计算两个指针之间的差值

    mov    eax, DWORD PTR _eos$[ebp]  ; 将eos的值加载到eax中
    sub    eax, DWORD PTR _str$[ebp]  ; 用eos减去原始字符串指针
    sub    eax, 1                     ; 减去1，得到字符串长度（不包括结尾的空字符）
    mov    esp, ebp                   ; 恢复栈指针
    pop    ebp                        ; 恢复基址指针
    ret    0                          ; 返回结果（eax中保存着字符串长度）
_strlen ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>
<p><code>MOVSX</code>,即<code>MOV with Sign Extend</code>,从内存中读取8位数据，并存储到32位寄存器里</p>
<p>本例中，MOVSX将用原始数据的8位数据填充EDX寄存器的低8位；<mark>如果原始数据是负数，该指令将使用1填充第8到第31位（高24位），否则使用0填充高24位</mark>。</p>
<p>这是为了保证有符号型数据在类型转换后的数值保持不变。</p>
<p>举了个例子</p>
<p>假如char型数据的原始值是−2（0xFE），直接把整个字节复制到int型数据的最低8位上时，int型数据的值就变成0x000000FE，以有符号型数据的角度看它被转换为254了，而没有保持原始值−2。−2对应的int型数据是0xFFFFFFFE。所以，在把原始数据复制到目标变量之后，还要使用符号标志位填充剩余的数据，而这就是MOVSX的功能。</p>
</li>
</ul>
<hr />
<p><code>Non-optimizing GCC</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">				public strlen               ; 公共标志，使得其他模块可以调用该函数
strlen           proc near                   ; 声明一个near过程，命名为strlen

eos              &#x3D; dword ptr -4               ; 定义局部变量eos的栈偏移量为-4
arg_0            &#x3D; dword ptr  8               ; 定义参数arg_0（字符串指针）的栈偏移量为8

                 push    ebp                  ; 保存基址指针
                 mov     ebp, esp             ; 设置新的基址指针
                 sub     esp, 10h             ; 为局部变量分配16字节的栈空间
                 mov     eax, [ebp+arg_0]     ; 将传入的字符串指针加载到eax中
                 mov     [ebp+eos], eax       ; 将eax的值（即字符串指针）保存到局部变量eos中
loc_80483F0:
                 mov     eax, [ebp+eos]       ; 将eos的值加载到eax中
                 movzx   eax, byte ptr [eax]  ; 从eax指向的地址处加载一个字节，并零扩展为32位
                 test    al, al               ; 测试al寄存器的值（即当前字符是否为0）
                 setnz   al                   ; 如果al不为零，al &#x3D; 1；否则，al &#x3D; 0
                 add     [ebp+eos], 1         ; 将eos自增1，指向下一个字符
                 test    al, al               ; 测试al寄存器的值（即当前字符是否为零）
                 jnz     short loc_80483F0    ; 如果al不为零，跳转到loc_80483F0，继续循环

                 ; 循环结束（当前字符为0），计算字符串的长度
                 mov     edx, [ebp+eos]       ; 将eos的值加载到edx中
                 mov     eax, [ebp+arg_0]     ; 将传入的字符串指针加载到eax中
                 mov     ecx, edx             ; 将edx的值加载到ecx中
                 sub     ecx, eax             ; ecx &#x3D; edx - eax，计算eos与字符串起始地址的差值
                 mov     eax, ecx             ; 将ecx的值加载到eax中
                 sub     eax, 1               ; eax减去1，得到字符串的实际长度（不包括结尾的空字符）
                 leave                        ; 恢复栈指针和基址指针
                 retn                         ; 返回结果（eax中保存着字符串长度）
strlen           endp                        ; 过程结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>
<p>这里<code>sub esp,10h</code>,<code>eos</code>只需要4个字节，但是为了满足对齐要求分配了额外的12个字节</p>
</li>
<li>
<p><code>MOVZX</code>是<code>MOV with Zero-Extent</code>的缩写,将8位或16位数据转换为32位数据的时候，它直接复制原始数据到目标寄存器的相应低位，并且使用0填充剩余的高位。</p>
<p>==相当于一步完成了“xor eax, eax”和“mov al，[源8/16位数据]”2条指令</p>
</li>
<li>
<p><code>SETNZ</code>指令:如果AL的值不是0，则“test al, al”指令会设置标志寄存器ZF=0；而SETNZ（Not Zero）指令会在ZF＝0的时候，设置AL＝1。用白话解说，就是：<mark>如果AL不等于0，则跳到loc_80483F0处</mark>。编译器转译出来的代码中，有些代码确实没有实际意义</p>
</li>
</ul>
<hr />
<p><code>Optimizing MSVS</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">_str$ &#x3D; 8                                     ; size &#x3D; 4
_strlen PROC
        mov     edx, DWORD PTR _str$[esp-4]   ;用EDX作字符串指针
        mov     eax, edx                      ;  复制到 EAX

$LL2@strlen:
        mov     cl, BYTE PTR [eax]            ; CL &#x3D; *EAX
        inc     eax                           ; EAX++
        test    cl, cl                        ; CL&#x3D;&#x3D;0?
        jne     SHORT $LL2@strlen             ; no, continue loop
        sub     eax, edx                      ; 计算指针的变化量
        dec     eax                           ; decrement EAX
        ret     0
_strlen ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr />
<p><code>Optimizing GCC</code> <code>-O3</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">                public strlen
strlen          proc near

arg_0           &#x3D; dword ptr  8

                push    ebp
                mov     ebp, esp
                mov     ecx, [ebp+arg_0];ecx&#x3D;arg_0;
                mov     eax, ecx;eax&#x3D;arg_0

loc_8048418:
                movzx   edx, byte ptr [eax];edx&#x3D;*eop
                add     eax, 1;eop++
                test    dl, dl;if dl &#x3D;&#x3D;0?
                jnz     short loc_8048418;dl !&#x3D;0,loop
                not     ecx
                add     eax, ecx
                pop     ebp
                retn
strlen          endp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>
<p><code>movzx</code>替换为<code>mov dl byte ptr[eax]</code>也可，使用<code>movzx</code>或许是为了保证寄存器的高地址位不含有噪音数据</p>
</li>
<li>
<p><mark><code>NOT</code>，NOT指令对操作数的所有bit都进行非运算，等价于<code>XOR ECX,0xfffffffh</code>,<code>not ecx</code>的结果与某数相加,相当于某数减去<code>ECX</code>然后再减<code>1</code></mark></p>
<p>从而得到正确的字符串长度</p>
<p><code>not ecx</code>相当于<code>ecx=(-ecx)-1</code>，由位运算可以推导</p>
</li>
</ul>
<hr />
<p>Problems:</p>
<ol>
<li></li>
</ol>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">_s$   &#x3D;  8
_f    PROC
           mov  edx, DWORD PTR _s$[esp-4];edx&#x3D;_s
           mov  cl, BYTE PTR [edx];cl&#x3D;*_s&#x3D;8
           xor  eax, eax
           test cl, cl
           je   SHORT $LN2@f;if cl&#x3D;&#x3D;0,exit
           npad 4    ; align next label
$LL4@f:
           cmp  cl, 32;
           jne  SHORT $LN3@f;if cl!&#x3D;32,jmp LN3
           inc  eax;eax++
$LN3@f:
           mov  cl, BYTE PTR [edx+1];cl&#x3D;*(_s+1)
           inc  edx;eax++
           test cl, cl
           jne  SHORT $LL4@f;if cl!&#x3D;0;jmp LL4
$LN2@f:
           ret  0
_f         ENDP
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>_s<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">*</span>_s<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>_s<span class="token operator">==</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//' '相当于统计字符串的空格数</span>
        <span class="token punctuation">&#123;</span>
            count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> count<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="2">
<li></li>
</ol>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.LFB24:
        push      ebx                    ; 保存 ebx 寄存器的值
        mov       ecx, DWORD PTR [esp+8] ; 将参数(假设是字符串指针)传递给 ecx
        xor       eax, eax               ; 将 eax 寄存器清零 (计数器)
        movzx     edx, BYTE PTR [ecx]    ; 将字符串的第一个字符加载到 edx
        test      dl, dl                 ; 测试该字符是否为 null (字符串结尾)
        je        .L2                    ; 如果是 null, 跳转到 .L2 结束
.L3:
        cmp       dl, 32                 ; 比较该字符与空格 (ASCII 32)
        lea       ebx, [eax+1]           ; 计算当前计数器值加1的地址
        cmove     eax, ebx               ; 如果字符是空格，eax &#x3D; ebx (即eax加1)
        add       ecx, 1                 ; 将 ecx 指针前移一个字符
        movzx     edx, BYTE PTR [ecx]    ; 将下一个字符加载到 edx
        test      dl, dl                 ; 测试该字符是否为 null
        jne       .L3                    ; 如果不是 null, 跳转到 .L3 继续处理
.L2:
        pop       ebx                    ; 恢复 ebx 寄存器的值
        ret                              ; 返回
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><code>cmove</code> 指令是 x86 汇编中的条件移动指令之一，它的全名是<code>conditional move if equal</code>。这意味着当满足给定条件时，从源操作数移动到目标操作数，而如果条件不成立，则不进行移动.如果比较结果是相等（即当前字符是空格）<code>eax=ebx=eax+1</code></li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">*</span>str<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> temp<span class="token operator">=</span>count<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>str<span class="token operator">==</span><span class="token number">32</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            count<span class="token operator">=</span>temp<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> count<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>进一步简化代码就是计数所有空格字符</p>
<h2 id="chap16-数学计算指令的替换"><a class="markdownIt-Anchor" href="#chap16-数学计算指令的替换"></a> Chap16 数学计算指令的替换</h2>
<p><code>出于性能优化的考虑，编译器可能会将1条数学运算指令替换为其他的1条、甚至是一组等效指令。</code>例如<code>LEA</code>指令通常替代其他简单计算指令，<code>ADD</code>与<code>SUB</code>同样可以相互替换</p>
<h3 id="乘法"><a class="markdownIt-Anchor" href="#乘法"></a> 乘法</h3>
<h4 id="替换为加法运算"><a class="markdownIt-Anchor" href="#替换为加法运算"></a> 替换为加法运算</h4>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> a<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
         <span class="token keyword">return</span> a<span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用MSVC 2010（启用/Ox）进行编译，编译器会把“乘以8”的运算指令拆解为3条加法指令。</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov     eax, DWORD PTR _a$[esp-4]
add     eax, eax
add     eax, eax
add     eax, eax
ret     0 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="替换为移位运算"><a class="markdownIt-Anchor" href="#替换为移位运算"></a> 替换为移位运算</h4>
<p>编译器通常会把“乘以2”“除以2”的运算指令处理为位移运算指令</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> a<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> a<span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">_a$ &#x3D; 8          ; size &#x3D; 4
_f       PROC
         push    ebp
         mov     ebp, esp
         mov     eax, DWORD PTR _a$[ebp]
         shl     eax, 2;shift left
         pop     ebp
         ret     0
_f       ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="替换为移位加减法的混合运算"><a class="markdownIt-Anchor" href="#替换为移位加减法的混合运算"></a> 替换为移位,加减法的混合运算</h4>
<p>即使乘数是7或17，乘法运算仍然可以用非乘法运算指令配合位移指令实现。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span>

<span class="token keyword">int</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
         <span class="token keyword">return</span> a<span class="token operator">*</span><span class="token number">7</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
         <span class="token keyword">return</span> a<span class="token operator">*</span><span class="token number">28</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
         <span class="token keyword">return</span> a<span class="token operator">*</span><span class="token number">17</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; a*7
_a$ &#x3D; 8
_f1      PROC
         mov     ecx, DWORD PTR _a$[esp-4]
; ECX&#x3D;a
         lea     eax, DWORD PTR [ecx*8]
; EAX&#x3D;ECX*8
         sub     eax, ecx
; EAX&#x3D;EAX-ECX&#x3D;ECX*8-ECX&#x3D;ECX*7&#x3D;a*7
         ret     0 
_f1     ENDP

; a*28
_a$ &#x3D; 8
_f2     PROC
         mov     ecx, DWORD PTR _a$[esp-4]
; ECX&#x3D;a
         lea     eax, DWORD PTR [ecx*8]
; EAX&#x3D;ECX*8
         sub     eax, ecx
; EAX&#x3D;EAX-ECX&#x3D;ECX*8-ECX&#x3D;ECX*7&#x3D;a*7
         shl     eax, 2
; EAX&#x3D;EAX&lt;&lt;2&#x3D;(a*7)*4&#x3D;a*28
         ret     0 
_f2     ENDP

; a*17
_a$ &#x3D; 8
_f3     PROC
         mov     eax, DWORD PTR _a$[esp-4]
; EAX&#x3D;a
         shl     eax, 4
; EAX&#x3D;EAX&lt;&lt;4&#x3D;EAX*16&#x3D;a*16
         add     eax, DWORD PTR _a$[esp-4]
; EAX&#x3D;EAX+a&#x3D;a*16+a&#x3D;a*17
         ret     0
_f3     ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="除法运算"><a class="markdownIt-Anchor" href="#除法运算"></a> 除法运算</h3>
<h4 id="替换为位移运算"><a class="markdownIt-Anchor" href="#替换为位移运算"></a> 替换为位移运算</h4>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> a<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
       <span class="token keyword">return</span> a<span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>shr eax,2</code></p>
<h3 id="problem-3"><a class="markdownIt-Anchor" href="#problem-3"></a> Problem</h3>
<ol>
<li></li>
</ol>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">_a$ &#x3D; 8
_f      PROC
        mov     ecx, DWORD PTR _a$[esp-4];ecx&#x3D;a
        lea     eax, DWORD PTR [ecx*8];eax&#x3D;a*8
        sub     eax, ecx;eax&#x3D;eax-a&#x3D;7a
        ret     0
_f      ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="chap17-fpu"><a class="markdownIt-Anchor" href="#chap17-fpu"></a> Chap17 FPU</h2>
<ul>
<li>
<p><code>FPU是专门处理浮点数的运算单元，是CPU的一个组件。</code></p>
</li>
<li>
<p><code>IEEE 754 </code>标准规定了计算机程序设计环境中的二进制和十进制的浮点数的交换、算术格式以及方法。符合这种标准的浮点数由符号位、尾数（又称为有效数字、小数位）和指数位构成。</p>
</li>
<li>
<p>在80486处理器问世之前，FPU（与CPU位于不同的芯片）叫作协作（辅助）处理器。而且那个时候的FPU还不属于主板的标准配置；如果想要在主板上安装FPU，人们还得单独购买它。</p>
<p>80486 DX之后的CPU处理器集成了FPU的功能。</p>
<p>若没有FWAIT指令和opcode以D8～DF开头的所谓的“ESC”字符指令（opcode以D8～DF开头），恐怕很少有人还会想起FPU属于独立运算单元的这段历史。FWAIT指令的作用是让CPU等待FPU运算结束，而ESC字符指令都在FPU上执行。</p>
<p>FPU自带一个由<code>8个80位寄存器构成的循环栈</code>。这些80位寄存器用以存储IEEE 754格式的浮点数据，通常叫作<code>ST(0)～ST(7)寄存器</code>。IDA和OllyDbg都把ST(0)显示为ST。也有不少教科书把ST(0)叫作“栈顶/Stack Top”寄存器。</p>
</li>
</ul>
<hr />
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">double</span> <span class="token function">f</span> <span class="token punctuation">(</span><span class="token keyword">double</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
          <span class="token keyword">return</span> a<span class="token operator">/</span><span class="token number">3.14</span> <span class="token operator">+</span> b<span class="token operator">*</span><span class="token number">4.1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">&#123;</span>
          <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"%f\n"</span><span class="token punctuation">,</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1.2</span><span class="token punctuation">,</span> <span class="token number">3.4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">CONST    SEGMENT
__real@4010666666666666 DQ 04010666666666666r ; 4.1    ; 定义常量4.1，存储在段&#96;CONST&#96;中
CONST    ENDS
CONST    SEGMENT
__real@40091eb851eb851f DQ 040091eb851eb851fr ; 3.14   ; 定义常量3.14，存储在段&#96;CONST&#96;中
CONST    ENDS
_TEXT    SEGMENT
_a$ &#x3D; 8             ; 变量&#96;_a&#96;的偏移量，相对于基指针(&#96;ebp&#96;)的8字节位置
_b$ &#x3D; 16            ; 变量&#96;_b&#96;的偏移量，相对于基指针(&#96;ebp&#96;)的16字节位置

_f PROC                ; &#96;_f&#96; 是一个过程（函数）
   push    ebp         ; 保存调用者的栈帧基指针，把当前&#96;ebp&#96;值推入栈
   mov     ebp, esp    ; 将栈指针&#96;esp&#96;的值保存在栈帧基指针&#96;ebp&#96;中，建立函数栈帧
   fld     QWORD PTR _a$[ebp]
                        ; 将ebp偏移_a的值（即变量_a的值）加载到FPU（浮点运算单元）堆栈中

; 当前FPU堆栈状态: ST(0) &#x3D; _a

   fdiv   QWORD PTR __real@40091eb851eb851f
                        ; 将ST(0)中的值除以常量3.14，并将结果存储在ST(0)中

; 当前FPU堆栈状态: ST(0) &#x3D; _a &#x2F; 3.14

   fld    QWORD PTR _b$[ebp]
                        ; 将ebp偏移_b的值（即变量_b的值）加载到FPU堆栈中

; 当前FPU堆栈状态: ST(0) &#x3D; _b; ST(1) &#x3D; _a &#x2F; 3.14

   fmul   QWORD PTR __real@4010666666666666
                        ; 将ST(0)中的值乘以常量4.1，并将结果存储在ST(0)中

; 当前FPU堆栈状态: ST(0) &#x3D; _b * 4.1; ST(1) &#x3D; _a &#x2F; 3.14

   faddp ST(1), ST(0)
                        ; 将ST(0)和ST(1)中的值相加，并将结果存储在ST(1)中，
                        ; 然后弹出堆栈顶（即ST(0)），堆栈平衡

; 当前FPU堆栈状态: ST(0) &#x3D; (_a &#x2F; 3.14) + (_b * 4.1)

   pop   ebp            ; 恢复调用者的基指针，将栈顶的值弹出到&#96;ebp&#96;中
   ret   0              ; 从函数返回，传递0个参数给调用者
_f  ENDP                ; 结束过程定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>汇编解读</p>
<ul>
<li><code>FLD</code>指令从栈中读取8个字节，把这个值转换成<code>FPU</code>寄存器所需的80位数据格式，并存入<code>ST(0)</code>寄存器</li>
<li><code>FDIV</code>指令把<code>ST(0)</code>寄存器的值用作被除数,把参数<code>__real@40091eb851eb851f</code>（即3.14）的值当作除数.因为汇编语法不支持含有小数点的浮点立即数，所以程序使用64位IEEE 754格式的16进制数</li>
<li>进行<code>FDIV</code>运算之后，<code>ST(0)</code>寄存器将保存商</li>
<li>此外，<code>FDIVP</code>也是FPU的除法运算指令。FDIVP在进行ST(1)/ST(0)运算时，先把两个寄存器的值POP出来进行运算，再把商推送入(PUSH)FPU的栈（即ST(0)寄存器）。</li>
<li>下一条<code>FLD</code>指令把<code>b</code>送入<code>FPU</code>的栈中</li>
<li>此时<code>ST(1)</code>寄存器里是上次除法运算的商，<code>ST(0)</code>寄存器里是变量<code>b</code>的值</li>
<li>接下来的<code>FMUL</code>指令做乘法运算，它用ST(0)寄存器里的值（即变量<em>b</em>），乘以参数__real @4010666666666666（即4.1），并将运算结果（积）存储到ST(0)寄存器。</li>
<li>最后一条运算指令FADDP计算栈内顶部两个值的和。它<code>先把运算结果存储在ST(1)寄存器，再POP ST(0)</code>。所以，<mark>运算表达式的运算结果存储在栈顶的ST(0)寄存器里。</mark></li>
<li>根据有关规范，<mark>函数必须使用ST(0)寄存器存储浮点运算的返回结果</mark>。所以在FADDP指令之后，除了函数尾声的指令之外再无其他指令。</li>
</ul>
<hr />
<p><code>GCC -O3</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; 定义过程 f，作为一个近过程
public f
f proc near

; 定义过程的参数
arg_0 &#x3D; qword ptr 8      ; 第一个参数的偏移量，相对于&#96;ebp&#96;的8字节位置
arg_8 &#x3D; qword ptr 10h    ; 第二个参数的偏移量，相对于&#96;ebp&#96;的16字节位置

                push    ebp      ; 把调用者的栈帧基指针&#96;ebp&#96;推入栈中，保留调用者的栈帧
                fld     ds:dbl_8048608 ; 加载全局数据段中的常量3.14到FPU（浮点运算单元）堆栈

; 当前栈状态: ST(0) &#x3D; 3.14
                mov     ebp, esp ; 创建新的栈帧，ebp指向当前栈顶
                fdivr   [ebp+arg_0] ; 反除法指令，将ST(0)中的常量3.14除以第一个参数（arg_0）

; 当前栈状态: ST(0) &#x3D; 除法结果 (3.14 &#x2F; arg_0)
                fld     ds:dbl_8048610 ; 加载全局数据段中的常量4.1到FPU堆栈

; 当前栈状态: ST(0) &#x3D; 4.1, ST(1) &#x3D; 除法结果
                fmul    [ebp+arg_8] ; 将ST(0)中的4.1乘以第二个参数（arg_8）

; 当前栈状态: ST(0) &#x3D; 乘法结果 (4.1 * arg_8), ST(1) &#x3D; 除法结果
                pop     ebp      ; 恢复调用者的栈帧，将栈顶的值弹出到ebp中
                faddp   st(1), st ; 将ST(0)和ST(1)相加，并将结果存储在ST(1)中，
                                  ; 然后弹出堆栈顶（即ST(0)），栈平衡

; 当前栈状态: ST(0) &#x3D; 加法结果 ((3.14 &#x2F; arg_0) + (4.1 * arg_8))
                ret               ; 从过程返回，返回地址从栈顶弹出
f endp           ; 结束过程定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>
<p><code>gcc</code>把3.14送入FPU的栈中(ST(0)寄存器),用作<code>arg_0</code>的除数</p>
</li>
<li>
<p><code>FDIVR</code>是<code>Reverse Divide</code>的缩写。<code>FDIVR</code>指令的除数和被除数，对应<code>FDIV</code>指令的被除数和除数，即位置相反，<code>FDIV</code>是<code>ST[0]</code>作为被除数，<code>FDIVR</code>是<code>ST[0]</code>作除数</p>
<p>其他相同</p>
</li>
</ul>
<h4 id="利用参数传递浮点型"><a class="markdownIt-Anchor" href="#利用参数传递浮点型"></a> 利用参数传递浮点型</h4>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;math.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">&#123;</span>
        <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"32.01 ^ 1.54 = %lf\n"</span><span class="token punctuation">,</span> <span class="token function">pow</span> <span class="token punctuation">(</span><span class="token number">32.01</span><span class="token punctuation">,</span><span class="token number">1.54</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>msvs x86</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">CONST    SEGMENT
__real@40400147ae147ae1 DQ 040400147ae147ae1r    ; 32.01  ; 定义常量32.01，存储在段&#96;CONST&#96;中
__real@3ff8a3d70a3d70a4 DQ 03ff8a3d70a3d70a4r    ; 1.54   ; 定义常量1.54，存储在段&#96;CONST&#96;中
CONST    ENDS

_main    PROC                          ; 主过程 _main 的开始
    push   ebp                         ; 将调用者的栈帧基指针&#96;ebp&#96;推入栈，保留调用者的栈帧
    mov    ebp, esp                    ; 将当前栈顶指针&#96;esp&#96;的值赋给&#96;ebp&#96;，建立新的栈帧
    sub    esp, 8                      ; 为第1个变量分配8个字节的栈空间
    fld    QWORD PTR __real@3ff8a3d70a3d70a4   ; 加载常量1.54到FPU（浮点运算单元）堆栈
    fstp   QWORD PTR [esp]             ; 将FPU堆栈顶部（ST(0)）的值存储到栈顶（对应第1个变量的空间）
    sub    esp, 8                      ; 为第2个变量分配8个字节的栈空间
    fld    QWORD PTR __real@40400147ae147ae1   ; 加载常量32.01到FPU堆栈
    fstp   QWORD PTR [esp]             ; 将FPU堆栈顶部的值存储到栈顶（对应第2个变量的空间）
    call   _pow                        ; 调用&#96;_pow&#96;函数计算幂（默认底数在 [esp + 8]，指数在 [esp]）

    add    esp, 8                      ; 调整栈指针，释放第2个变量的空间
                                       
; 栈分配了8个字节的空间用于存储函数 &#96;_pow&#96; 的结果
; 运算结果存储于FPU堆栈的ST(0)寄存器

    fstp   QWORD PTR [esp]             ; 将FPU堆栈顶部的值（&#96;_pow&#96;结果）存储到栈顶，供&#96;printf()&#96;使用
    push   OFFSET $SG2651              ; 推送格式字符串的地址到栈，用于&#96;printf()&#96;调用
    call   _printf                     ; 调用&#96;printf()&#96;函数打印结果
    add    esp, 12                     ; 调整栈指针，释放用于&#96;printf&#96;调用的栈空间（8字节结果 + 4字节地址）
    xor    eax, eax                    ; 将&#96;eax&#96;寄存器置零，表示程序返回值为0
    pop    ebp                         ; 恢复调用者的栈帧，将栈顶的值弹出到&#96;ebp&#96;中
    ret    0                           ; 从过程返回，传递0个参数给调用者
_main    ENDP                          ; 结束过程定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>汇编解读</p>
<ul>
<li>FLD和FSTP指令是在数据段（SEGMENT）和FPU的栈间交换数据的指令。<mark>FLD把内存里的数据推送入FPU的栈</mark>，而<mark>FSTP则把FPU栈顶的数据<code>复制</code>到内存中</mark>。这两个连用相当于使浮点数给入栈了,给pow传递参数</li>
<li>pow()函数是指数运算函数，它从<mark>FPU的栈内读取两个参数进行计算，并把运算结果（<em>x</em>的<em>y</em>次幂）存储在ST(0)寄存器里</mark>。之后，printf()函数先从内存栈中读取8个字节的数据，再以双精度浮点的形式进行输出。</li>
<li>此外，这个例子里还可以<mark>直接成对使用MOV指令把浮点数据从内存复制到FPU的栈里。内存本身就把浮点数据存储为IEEE 754的数据格式，而pow()函数所需的参数就是这个格式的数据，所以此处没有格式转换的必要</mark>。</li>
</ul>
<h4 id="比较说明"><a class="markdownIt-Anchor" href="#比较说明"></a> 比较说明</h4>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">double</span> <span class="token function">d_max</span> <span class="token punctuation">(</span><span class="token keyword">double</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">></span>b<span class="token punctuation">)</span>
                <span class="token keyword">return</span> a<span class="token punctuation">;</span>

        <span class="token keyword">return</span> b<span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">&#123;</span>
        <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"%f\n"</span><span class="token punctuation">,</span> <span class="token function">d_max</span> <span class="token punctuation">(</span><span class="token number">1.2</span><span class="token punctuation">,</span> <span class="token number">3.4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"%f\n"</span><span class="token punctuation">,</span> <span class="token function">d_max</span> <span class="token punctuation">(</span><span class="token number">5.6</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr />
<p><code>Non-Optimizing MSVS</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">PUBLIC    _d_max
_TEXT    SEGMENT
_a$ &#x3D; 8              ; 变量_a$在栈帧中的偏移，大小为8字节
_b$ &#x3D; 16             ; 变量_b$在栈帧中的偏移，大小为8字节
_d_max     PROC
    push   ebp               ; 保存旧的基址指针
    mov    ebp, esp          ; 将当前栈顶指针赋值给基址指针
    fld    QWORD PTR _b$[ebp]; 加载_b$，将其压入FPU堆栈的ST(0)寄存器

    ; 当前堆栈状态：ST(0) &#x3D; _b
    ; 比较_b（ST(0)）和_a$，然后弹出寄存器

    fcomp  QWORD PTR _a$[ebp]; 比较ST(0)和_a$，并弹出ST(0)

    ; 此时FPU堆栈为空

    fnstsw ax                ; 将FPU状态字存储到AX寄存器
    test   ah, 5             ; 检查AX寄存器的高8位的第0和第2位(对应的是C2,C0标志位)
    jp     SHORT $LN1@d_max  ; 如果标志位有正数标志(a&lt;&#x3D;b)，则跳转到$LN1@d_max

    ; 如果_a &gt; _b，继续执行以下代码

    fld    QWORD PTR _a$[ebp]; 加载_a$，将其压入FPU堆栈的ST(0)
    jmp    SHORT $LN2@d_max  ; 跳转到$LN2@d_max
$LN1@d_max:
    fld    QWORD PTR _b$[ebp]; 加载_b$，将其压入FPU堆栈的ST(0)
$LN2@d_max:
    pop    ebp               ; 恢复基址指针
    ret    0                 ; 返回
_d_max    ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>
<p><code>FCOMP</code>首先比较<code>ST(0)</code>与<code>_a</code>的值，然后根据比较的结果设置<code>FPU</code>状态字(寄存器)的C3/C2/C0位。<mark><code>FPU</code>的状态字寄存器是一个16位寄存器，用于描述<code>FPU</code>的当前状态</mark></p>
<ul>
<li>如果<em>b</em>&gt;a，则C3、C2、C0寄存器的值会分别是0、0、0。</li>
<li>如果<em>a</em>&gt;<em>b</em>，则寄存器的值会分别是0、0、1。</li>
<li>如果<em>a</em>=<em>b</em>，则寄存器的值会分别是1、0、0。</li>
<li>如果出现了错误（NaN或数据不兼容），则寄存器的值是1、1、1。</li>
</ul>
<p>在设置好相应比特位之后，<code>FCOMP指令还会从栈里抛出（POP）一个值</code>。FCOM与FCOMP的功能十分相似。<code>FCOM指令只根据数值比较的结果设置状态字，而不会再操作FPU的栈</code>。</p>
</li>
<li>
<p><code>FNSTSW</code> 指令在 x86 汇编中用于将浮点状态字（<code>Floating Point Status Word</code>）存储到指定位置或 AX 寄存器中</p>
<p><code>F</code>:操作前不等待FPU可用</p>
<p><code>NST</code>:No STore到内存操作</p>
<p><code>SW</code>:Status Word(状态字)</p>
<p>C3/C2/C0标志位对应AX的第14/10/8位。<code>复制数值并不会改变标志位（bit）的数权（位置）</code>。标志位会集中在AX寄存器的高地址位区域——即AH寄存器里。</p>
<p>以AH来看:0:C0   1:C1   2:C2   6:C3</p>
<p><code>test ah, 5</code>指令把ah的值（FPU标志位的加权求和值）和0101（二进制的5）做与（AND）运算，并设置标志位。影响test结果的只有第0比特位的C0标志位和第2比特位的C2标志位，因为其他的位都会被置零。</p>
</li>
<li>
<p>奇偶校验位PF（parity flag）的介绍</p>
<p><mark>PF标志位的作用是判定运算结果中的“1”的个数，如果“1”的个数为偶数，则PF的值为1，否则其值为0。</mark></p>
<p>检验奇偶位通常用于判断处理过程是否出现故障，并<mark>不能判断这个数值是奇数还是偶数</mark>。FPU有四个条件标志位（C0到C3）。但是，必须把标志位的值组织起来、存放在标志位寄存器中，才能进行奇偶校验位的正确性验证。FPU标志位的用途各有不同：<mark>C0位是进位标志位CF，C2是奇偶校验位PF，C3是零标志位ZF</mark></p>
<p>在使用FUCOM指令（FPU比较指令的通称）时，<mark>如果操作数里出现了不可比较的浮点值（非数值型内容NaN或其他无法被指令支持的格式），则C2会被设为1。</mark></p>
<p><mark>如果C0和C2都是0或都是1，则设PF标志为1并触发JP跳转（Jump on Parity</mark>）。前面对C3/C2/C0的取值进行了分类讨论，<mark>C2和C0的数值相同的情况分为<em>b</em>&gt;<em>a</em>和 <em>a</em>=<em>b</em>这两种情况。因为test指令把ah的值与5进行“与”运算，所以C3的值无关紧要</mark>。</p>
<p>在此之后的指令就很简单了。如果触发了JP跳转，则FLD指令把变量_b的值复制到ST(0)寄存器，否则变量_a的值将会传递给ST（0）寄存器。</p>
<p>如果需要检测C2的状态</p>
<p>如果TEST指令遇到错误（NaN等情形），则C2标志位的值会被设置为1。不过我们的程序不检测这类错误。<code>如果编程人员需要处理FPU的错误，他就不得不添加额外的错误检查指令</code>。</p>
</li>
</ul>
<hr />
<p><code>Optimizing MSVS 2010</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">_a$ &#x3D; 8                  ; size &#x3D; 8
_b$ &#x3D; 16                 ; size &#x3D; 8
_d_max     PROC
    fld     QWORD PTR _b$[esp-4]
    fld     QWORD PTR _a$[esp-4]

; current stack state: ST(0) &#x3D; _a, ST(1) &#x3D; _b

    fcom    ST(1) ; compare _a and ST(1) &#x3D; (_b)
    fnstsw  ax
    test    ah, 65 ; 00000041H
    jne     SHORT $LN5@d_max
; copy ST(0) to ST(1) and pop register,
; leave (_a) on top
    fstp    ST(1)

; current stack state: ST(0) &#x3D; _a

    ret     0
$LN5@d_max:
; copy ST(0) to ST(0) and pop register,
; leave (_b) on top
    fstp    ST(0)

; current stack state: ST(0) &#x3D; _b
    ret 0
_d_max ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>
<p>FCOM指令和前面用过的FCOMP指令略有不同，它不操作FPU栈。而且本例的操作数也和前文有区别，这里它是逆序的。所以，FCOM生成的条件标志位的涵义也与前例不同。</p>
<ul>
<li>如果<em>a</em>&gt;<em>b</em>，则C3、C2、C0位的值分别为0、0、0。</li>
<li>如果<em>b</em>&gt;<em>a</em>，则对应数值为0、0、1。</li>
<li>如果<em>a</em>=<em>b</em>，则对应数值为1、0、0。</li>
</ul>
</li>
<li>
<p>是说，“test ah, 65”这条指令仅仅比较两个标志位——C3（第6位/bit）和C0（第0位/bit）。在<em>a</em>&gt;<em>b</em>的情况下，两者都应为0：这种情况下，程序不会被触发JNE跳转，并会执行后面的FSTP ST(1)指令，把ST（0）的值复制到操作数中，然后从FPU栈里抛出一个值。换句话说，这条指令把ST（0）的值（即变量_a的值）复制到ST（1）寄存器；此后栈顶的2个值都是_a。然后，相当于POP出一个值来，使ST(0)寄存器的值为_a，函数随即结束。</p>
<p>在<em>b</em>&gt;<em>a</em>或<em>a</em>==<em>b</em>的情况下，程序将触发条件转移指令JNE。从ST(0)取值、再赋值给ST(0)寄存器，相当于NOP操作没有实际意义。接着它从栈里POP出一个值，使ST(0)的值为先前ST(1)的值，也就是变量_b。然后结束本函数。大概是因为FPU的指令集里没有POP并舍弃栈顶值的指令，所以才会出现这样的汇报指令。</p>
</li>
</ul>
<h2 id="chap18-数组"><a class="markdownIt-Anchor" href="#chap18-数组"></a> Chap18 数组</h2>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"a[%d]=%d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用msvs 2008 进行编译</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">_TEXT     SEGMENT
_i$ &#x3D; -84              ; size &#x3D; 4
_a$ &#x3D; -80              ; size &#x3D; 80
_main      PROC
    push   ebp
    mov    ebp, esp
    sub    esp, 84    ; 00000054H
    mov    DWORD PTR _i$[ebp], 0;i&#x3D;0
    jmp    SHORT $LN6@main
$LN5@main:;i+&#x3D;1 
    mov    eax, DWORD PTR _i$[ebp]
    add    eax,  1
    mov    DWORD PTR _i$[ebp], eax
$LN6@main:
    cmp    DWORD PTR _i$[ebp], 20; 00000014H
    jge    SHORT $LN4@main
    mov    ecx, DWORD PTR _i$[ebp];i&lt;20
    shl    ecx, 1;ecx*2&#x3D;2i
    mov    edx, DWORD PTR _i$[ebp]
    mov    DWORD PTR _a$[ebp+edx*4], ecx;a[i]&#x3D;2i
    jmp    SHORT $LN5@main
$LN4@main:;i&#x3D;0
    mov    DWORD PTR _i$[ebp], 0
    jmp    SHORT $LN3@main
$LN2@main:
    mov    eax, DWORD PTR _i$[ebp]
    add    eax, 1
    mov    DWORD PTR _i$[ebp], eax
$LN3@main:;for i in range(20) printf(a[i])
    cmp    DWORD PTR _i$[ebp], 20    ; 00000014H
    jge    SHORT $LN1@main;ret
    mov    ecx, DWORD PTR _i$[ebp]
    mov    edx, DWORD PTR _a$[ebp+ecx*4]
    push   edx
    mov    eax, DWORD PTR _i$[ebp]
    push   eax
    push   OFFSET $SG2463
    call   _printf
    add    esp, 12        ; 0000000cH
    jmp    SHORT $LN2@main
$LN1@main:
    xor    eax, eax
    mov    esp, ebp
    pop    ebp
    ret    0
_main      ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>程序为数组申请了80字节的栈空间，以存储20个4字节元素。</li>
<li>因为全部数组都存储于栈中，所以我们可以在内存数据窗口里看到整个数组。</li>
</ul>
<hr />
<p>gcc</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">                public main
main            proc near                   ; DATA XREF: _start+17

var_70          &#x3D; dword ptr -70h
var_6C          &#x3D; dword ptr -6Ch
var_68          &#x3D; dword ptr -68h
i_2             &#x3D; dword ptr -54h
i               &#x3D; dword ptr -4

                push     ebp
                mov      ebp, esp
                and      esp, 0FFFFFFF0h;对齐
                sub      esp, 70h
                mov      [esp+70h+i], 0     ; i&#x3D;0
                jmp      short loc_804840A

loc_80483F7:
                mov      eax, [esp+70h+i]
                mov      edx, [esp+70h+i]
                add      edx, edx           ; edx&#x3D;i*2
                mov      [esp+eax*4+70h+i_2], edx
                add      [esp+70h+i], 1     ;  i++

loc_804840A:
                cmp      [esp+70h+i], 13h;19
                jle      short loc_80483F7;i&lt;&#x3D;19
                mov      [esp+70h+i], 0;i&#x3D;0
                jmp      short loc_8048441

loc_804841B:
                mov      eax, [esp+70h+i]
                mov      edx, [esp+eax*4+70h+i_2]
                mov      eax, offset aADD ; &quot;a[%d]&#x3D;%d\n&quot;
                mov      [esp+70h+var_68], edx
                mov      edx, [esp+70h+i]
                mov      [esp+70h+var_6C], edx
                mov      [esp+70h+var_70], eax
                call     _printf
                add      [esp+70h+i], 1

loc_8048441:
                cmp      [esp+70h+i], 13h
                jle      short loc_804841B;i&lt;&#x3D;19
                mov      eax, 0
                leave
                retn
main            endp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>
<p>实际上变量==<em>a</em>的数据类型是整型指针。严格地说，在把数组传递给函数的时候，传递的数据就是指向第一个元素的指针，我们再根据这个指针就可以轻松地计算出数组每个元素的地址（即指针）。==如果使用a[idx]的形式表示数组元素，其中idx是数组元素在数组里的排列序号（即索引号），那么就可以通过数组第一个元素的地址、索引号和数据容量求得各个元素的地址。</p>
<p>举个典型的例子：字符串常量“string”是字符型数组，它的每个字符元素都是const char*型数据。使用索引号之后，我们就可以使用“string”[i]的形式描述字符串中的第<em>i</em>个字符——这正是C/C＋＋表达式的表示方法！</p>
</li>
</ul>
<h3 id="缓冲区溢出"><a class="markdownIt-Anchor" href="#缓冲区溢出"></a> 缓冲区溢出</h3>
<p>从汇编代码可以看出:编译器没有对索引进行判断，</p>
<p>可以访问a[20]</p>
<hr />
<p>向数组边界之外的地址赋值</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i<span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">30</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
                 a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>程序发生了崩溃</p>
<p>使用onlydbg加载，跟踪程序崩溃原因</p>
<ul>
<li>
<p>当30个循环结束后，<code>EIP</code>的值是0x15，显然不合法，此时<code>EBP</code>为0x14，<code>ECX</code>和<code>EDX</code>值为0x1D</p>
<p>Why?</p>
</li>
<li>
<p>首先回顾栈的结构</p>
<p>，main()函数的栈结构如下：</p>
<table>
<thead>
<tr>
<th>ESP</th>
<th><em>i</em>所占用的4字节</th>
</tr>
</thead>
<tbody>
<tr>
<td>ESP+4</td>
<td><em>a</em>[20]占用的80字节</td>
</tr>
<tr>
<td>ESP+84</td>
<td>保存过的EBP</td>
</tr>
<tr>
<td>ESP+88</td>
<td>返回地址</td>
</tr>
</tbody>
</table>
<p>赋值给<em>a</em>[19]的时候，数组<em>a</em>[]已经被全部赋值。</p>
<p>赋值给a[20]实际上修改的是栈里保存的<code>EBP</code>，本例中将20赋值了给a[10],函数退出之前会将ebp设置为这个值，因此ebp为0x14</p>
<p>最后运行<code>RET</code>指令，相当于<code>POP EIP</code>，<code>RET</code>指令将程序的控制权传递给栈里的返回地址，不过此时这个值为0x15，这里没有可执行代码，因此崩溃</p>
</li>
<li>
<p>事实上，这就是缓冲区溢出攻击的原理，我们可以劫持返回地址来控制eip来跳转到其他程序的地址</p>
<p>目前已经有了很多手段来防御这种攻击，学pwn的时候再深入了解</p>
<ul>
<li>
<p>canary，随机写入随机数，在函数结束之前检查这些值是否发生变化</p>
</li>
<li>
<p>如果启用MSVC的RTC1和RTCs选项编译本章开头的那段程序，就会在汇编指令里看到函数在退出之前调用@_RTC_CheckStackVars@8，用以检测“百灵鸟”是否会报警。</p>
</li>
<li>
<p>用gcc编译</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">		mov     eax, DWORD PTR [ebp-12]
        xor     eax, DWORD PTR gs:20； 
        jne     .L5
        mov     ebx, DWORD PTR [ebp-4]
.L5:
        call    __stack_chk_fail<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>显然随机值位于gs：20,</p>
</li>
</ul>
</li>
<li>
<p>gs开头的寄存器就是常说的段寄存器。在MS-DOS和基于DOS的系统里，段寄存器的作用很广泛。但是，今天它的作用发生了变化。简单地说，Linux下的gs 寄存器总是指向TLS（参见第65章）——存储线程的多种特定信息。（Win32环境下的fs寄存器起到Linux下gs寄存器的作用。Win32的fs寄存器指向TIB）</p>
</li>
</ul>
<h3 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h3>
<p>现在我们应该可以理解为什么C/C++编译不了下面的程序了。</p>
<pre class="line-numbers language-none"><code class="language-none">void f(int size)
&#123;
    int a[size];
...
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><mark>在编译阶段，编译器必须确切地知道需要给数组分配多大的存储空间，它需要事先明确分配局部栈或数据段（全局变量）的格局，所以编译器无法处理上述这种长度可变的数组。</mark></p>
<p>如果无法事先确定数组的长度，那么我们就应当使用malloc()函数分配出一块内存，然后直接按照常规变量数组的方式访问这块内存；或者遵循C99标准（参见ISO07，6.7.5/2）进行处理，但是遵循C99标准而设计出来的程序，内部实现的方法更接近alloca()函数（详情请参阅5.2.4节）。</p>
<h3 id="字符串指针"><a class="markdownIt-Anchor" href="#字符串指针"></a> 字符串指针</h3>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> month1<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span>
<span class="token punctuation">&#123;</span>
        <span class="token string">"January"</span><span class="token punctuation">,</span>
        <span class="token string">"February"</span><span class="token punctuation">,</span>
        <span class="token string">"March"</span><span class="token punctuation">,</span>
        <span class="token string">"April"</span><span class="token punctuation">,</span>
        <span class="token string">"May"</span><span class="token punctuation">,</span>
        <span class="token string">"June"</span><span class="token punctuation">,</span>
        <span class="token string">"July"</span><span class="token punctuation">,</span>
        <span class="token string">"August"</span><span class="token punctuation">,</span>
        <span class="token string">"September"</span><span class="token punctuation">,</span>
        <span class="token string">"October"</span><span class="token punctuation">,</span>
        <span class="token string">"November"</span><span class="token punctuation">,</span>
        <span class="token string">"December"</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// in 0..11 range</span>
<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">get_month1</span> <span class="token punctuation">(</span><span class="token keyword">int</span> month<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> month1<span class="token punctuation">[</span>month<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr />
<p>msvs x64</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">_DATA   SEGMENT
month1  DQ      FLAT:$SG3122
        DQ      FLAT:$SG3123
        DQ      FLAT:$SG3124
        DQ      FLAT:$SG3125
        DQ      FLAT:$SG3126
        DQ      FLAT:$SG3127
        DQ      FLAT:$SG3128
        DQ      FLAT:$SG3129
        DQ      FLAT:$SG3130
        DQ      FLAT:$SG3131
        DQ      FLAT:$SG3132
        DQ      FLAT:$SG3133
$SG3122 DB     &#39;January&#39;, 00H
$SG3123 DB     &#39;February&#39;, 00H
$SG3124 DB     &#39;March&#39;, 00H
$SG3125 DB     &#39;April&#39;, 00H
$SG3126 DB     &#39;May&#39;, 00H
$SG3127 DB     &#39;June&#39;, 00H
$SG3128 DB     &#39;July&#39;, 00H
$SG3129 DB     &#39;August&#39;, 00H
$SG3130 DB     &#39;September&#39;, 00H
$SG3156 DB     &#39;%s&#39;, 0aH, 00H
$SG3131 DB     &#39;October&#39;, 00H
$SG3132 DB     &#39;November&#39;, 00H
$SG3133 DB     &#39;December&#39;, 00H
_DATA   ENDS

month$ &#x3D; 8
get_month1 PROC
         movsxd  rax, ecx
         lea     rcx, OFFSET FLAT:month1
         mov     rax, QWORD PTR [rcx+rax*8]
         ret     0
get_month1 ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><mark>MOVSXD</mark>把ECX的32位整型数值、连同其符号扩展位(sign-extension)扩展为64位整型数据，再存储于RAX寄存器中。ECX存储的“月份”信息是32位整形数据。因为程序随后还要进行64位运算，所以需要把输入变量转换为64位值。</li>
<li>然后函数把<code>指针表的地址存储于RCX寄存器。</code></li>
<li>最后，函数的输<code>入变量(month)的值乘以8、再与指针表的地址相加</code>。因为是64位系统的缘故，每个地址（即指针）的数据需要占用64位（即8字节）。所以指针表中的每个元素都占用8字节空间。因此，最终字符串的地址要加上month*8。MOV指令不仅完成了字符串地址的计算，而且还完成了指针表的查询。在输入值为1时，函数将返回字符串“February”的指针地址。</li>
</ul>
<hr />
<p><code>Optimizing gcc</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">movsx   rdi, edi
     mov     rax, QWORD PTR month1[0+rdi*8]
     ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<hr />
<p><code>Optimizing MSVS</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">_month$ &#x3D; 8
_get_month1 PROC
        mov     eax, DWORD PTR _month$[esp-4]
        mov     eax, DWORD PTR _month1[eax*4]
        ret     0
_get_month1 ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>32位程序就不用把输入值转化为64位数据了。此外，32位系统的指针属于4字节数据，所以相关的计算因子变为了4。</p>
<h3 id="多维数组"><a class="markdownIt-Anchor" href="#多维数组"></a> 多维数组</h3>
<p>计算机内存是连续的线性空间，它可以与一维数组直接对应。在被拆分成多个一维数组之后，多维数组与内栈线性空间同样存在直接对应的存储关系。</p>
<table>
<thead>
<tr>
<th>存储地址</th>
<th>数组元素</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>[0] [0]</td>
</tr>
<tr>
<td>1</td>
<td>[0] [1]</td>
</tr>
<tr>
<td>2</td>
<td>[0] [2]</td>
</tr>
<tr>
<td>3</td>
<td>[0] [3]</td>
</tr>
<tr>
<td>4</td>
<td>[1] [0]</td>
</tr>
<tr>
<td>5</td>
<td>[1] [1]</td>
</tr>
<tr>
<td>6</td>
<td>[1] [2]</td>
</tr>
<tr>
<td>7</td>
<td>[1] [3]</td>
</tr>
<tr>
<td>8</td>
<td>[2] [0]</td>
</tr>
<tr>
<td>9</td>
<td>[2] [1]</td>
</tr>
<tr>
<td>10</td>
<td>[2] [2]</td>
</tr>
<tr>
<td>11</td>
<td>[2] [3]</td>
</tr>
</tbody>
</table>
<p>在内存之中，3×4的二维数组将依次存储为连续的12个元素，如表18.2所示。</p>
<p>在<code>计算上述数组中某个特定元素的内存存储编号时，可以先将二维索引号的第一个索引号乘以4（矩阵宽度），而后加上第二个索引号。</code>这种方式就是C/C++、Python所用的“行优先的顺序”（row-majororder）。<mark>所谓行优先，就是先用第一行排满第一个索引号下的所有元素，然后再依次编排其他各行。</mark></p>
<p><code>从性能及缓存的角度来看，与数据的存储方案（scheme)和组织方式（data organization）匹配的优先顺序最优</code>。只要相互匹配，那么程序就可以连续访问数据，整体性能就会提高。所以，如果程序以“逐行”的方式访问数据，那么就应当以行优先的顺序组织数组；反之亦然。</p>
<hr />
<p>显然根据这种规则我们可以利用一维数组的方式访问二维数组</p>
<p>例如</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">char</span> <span class="token function">get_by_coordinates1</span> <span class="token punctuation">(</span><span class="token keyword">char</span> array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> array<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">char</span> <span class="token function">get_by_coordinates2</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>array<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token comment">// treat input array as one-dimensional</span>
        <span class="token comment">// 4 is array width here</span>
        <span class="token keyword">return</span> array<span class="token punctuation">[</span>a<span class="token operator">*</span><span class="token number">4</span><span class="token operator">+</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">char</span> <span class="token function">get_by_coordinates3</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>array<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token comment">// treat input array as pointer,</span>
        <span class="token comment">// calculate address, get value at it</span>
        <span class="token comment">// 4 is array width here</span>
        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span>array<span class="token operator">+</span>a<span class="token operator">*</span><span class="token number">4</span><span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">get_by_coordinates1</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">get_by_coordinates2</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span> <span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">get_by_coordinates3</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr />
<p><code>Optimizing gcc</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; RDI&#x3D;address of array
; RSI&#x3D;a
; RDX&#x3D;b

get_by_coordinates1:
; sign-extend input 32-bit int values &quot;a&quot; and &quot;b&quot; to 64-bit ones
        movsx   rsi, esi
        movsx   rdx, edx
        lea     rax, [rdi+rsi*4]
; RAX&#x3D;RDI+RSI*4&#x3D;address of array+a*4
        movzx   eax, BYTE PTR [rax+rdx]
; AL&#x3D;load byte at address RAX+RDX&#x3D;address of array+a*4+b
        ret

get_by_coordinates2:
        lea     eax, [rdx+rsi*4]
; RAX&#x3D;RDX+RSI*4&#x3D;b+a*4
        cdqe
        movzx   eax, BYTE PTR [rdi+rax]
; AL&#x3D;load byte at address RDI+RAX&#x3D;address of array+b+a*4
        ret

get_by_coordinates3:
        sal     esi, 2
; ESI&#x3D;a&lt;&lt;2&#x3D;a*4
; sign-extend input 32-bit int values &quot;a*4&quot; and &quot;b&quot; to 64-bit ones
        movsx   rdx, edx
        movsx   rsi, esi
        add     rdi, rsi
; RDI&#x3D;RDI+RSI&#x3D;address of array+a*4
        movzx   eax, BYTE PTR [rdi+rdx]
; AL&#x3D;load byte at address RDI+RDX&#x3D;address of array+a*4+b
        ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>三者汇编很接近并且计算的下标是一样的</p>
<hr />
<p>多维数组的情况也差不多，例如三维</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        a<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token operator">=</span>value<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>msvs x86</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">_DATA      SEGMENT
COMM       _a:DWORD:01770H
_DATA      ENDS
PUBLIC     _insert
_TEXT      SEGMENT
_x$ &#x3D; 8               ; size &#x3D; 4
_y$&#x3D;12                ; size &#x3D; 4
_z$&#x3D;16                ; size &#x3D; 4
_value$ &#x3D; 20          ; size &#x3D; 4
_insert     PROC
    push    ebp
    mov     ebp, esp
    mov     eax, DWORD PTR _x$[ebp]
    imul    eax, 2400                ; eax&#x3D;600*4*x
    mov     ecx, DWORD PTR _y$[ebp]
    imul    ecx, 120                 ; ecx&#x3D;30*4*y
    lea     edx, DWORD PTR _a[eax+ecx]; edx&#x3D;a + 600*4*x + 30*4*y
    mov     eax, DWORD PTR _z$[ebp]
    mov     ecx, DWORD PTR _value$[ebp]
    mov     DWORD PTR [edx+eax*4], ecx; *(edx+z*4)&#x3D;value
    pop     ebp
    ret     0
_insert     ENDP
_TEXT       ENDS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>数组元素地址=600×4<em>x</em> + 30×4<em>y</em> + 4<em>z</em>。32位系统里int类型是32位（4字节）数据，所以要每项都要乘以4。</p>
<hr />
<p><code>gcc</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">           public  insert
insert     proc near

x          &#x3D; dword ptr 8
y          &#x3D; dword ptr  0Ch
z          &#x3D; dword ptr  10h
value      &#x3D; dword ptr  14h

           push    ebp
           mov     ebp, esp
           push    ebx
           mov     ebx, [ebp+x];ebx&#x3D;x
           mov     eax, [ebp+y];eax&#x3D;y
           mov     ecx, [ebp+z];ecx&#x3D;z
           lea     edx, [eax+eax]              ; edx&#x3D;y*2
           mov     eax, edx                    ; eax&#x3D;y*2
           shl     eax, 4                      ; eax&#x3D;(y*2)&lt;&lt;4 &#x3D; y*2*16 &#x3D; y*32
           sub     eax, edx                    ; eax&#x3D;y*32 - y*2&#x3D;y*30
           imul    edx, ebx, 600               ; edx&#x3D;x*600
           add     eax, edx                    ; eax&#x3D;eax+edx&#x3D;y*30 + x*600
           lea     edx, [eax+ecx]              ; edx&#x3D;y*30 + x*600 + z
           mov     eax, [ebp+value]
           mov     dword ptr ds:a[edx*4], eax  ; *(a+edx*4)&#x3D;value
           pop     ebx
           pop     ebp
           retn
insert     endp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>gcc在计算30y进行了优化;(<em>y</em> + <em>y</em>) &lt;&lt; 4 − (<em>y</em> + <em>y</em>) = (2 <em>y</em>)&lt;&lt; 4 − 2 <em>y</em> = 2×16<em>y</em> − 2 <em>y</em> = 32 <em>y</em> − 2 <em>y</em> = 30 <em>y</em></li>
</ul>
<hr />
<p>计算机的显示屏幕是一个2D显示空间，但是显存却是一个一维线性数组。</p>
<h3 id="二维字符串数组的封装格式"><a class="markdownIt-Anchor" href="#二维字符串数组的封装格式"></a> 二维字符串数组的封装格式</h3>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h></span></span>

<span class="token keyword">const</span> <span class="token keyword">char</span> month2<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">=</span>
<span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#123;</span> <span class="token char">'J'</span><span class="token punctuation">,</span><span class="token char">'a'</span><span class="token punctuation">,</span><span class="token char">'n'</span><span class="token punctuation">,</span><span class="token char">'u'</span><span class="token punctuation">,</span><span class="token char">'a'</span><span class="token punctuation">,</span><span class="token char">'r'</span><span class="token punctuation">,</span><span class="token char">'y'</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#123;</span> <span class="token char">'F'</span><span class="token punctuation">,</span><span class="token char">'e'</span><span class="token punctuation">,</span><span class="token char">'b'</span><span class="token punctuation">,</span><span class="token char">'r'</span><span class="token punctuation">,</span><span class="token char">'u'</span><span class="token punctuation">,</span><span class="token char">'a'</span><span class="token punctuation">,</span><span class="token char">'r'</span><span class="token punctuation">,</span><span class="token char">'y'</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#123;</span> <span class="token char">'M'</span><span class="token punctuation">,</span><span class="token char">'a'</span><span class="token punctuation">,</span><span class="token char">'r'</span><span class="token punctuation">,</span><span class="token char">'c'</span><span class="token punctuation">,</span><span class="token char">'h'</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#123;</span> <span class="token char">'A'</span><span class="token punctuation">,</span><span class="token char">'p'</span><span class="token punctuation">,</span><span class="token char">'r'</span><span class="token punctuation">,</span><span class="token char">'i'</span><span class="token punctuation">,</span><span class="token char">'l'</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#123;</span> <span class="token char">'M'</span><span class="token punctuation">,</span><span class="token char">'a'</span><span class="token punctuation">,</span><span class="token char">'y'</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#123;</span> <span class="token char">'J'</span><span class="token punctuation">,</span><span class="token char">'u'</span><span class="token punctuation">,</span><span class="token char">'n'</span><span class="token punctuation">,</span><span class="token char">'e'</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#123;</span> <span class="token char">'J'</span><span class="token punctuation">,</span><span class="token char">'u'</span><span class="token punctuation">,</span><span class="token char">'l'</span><span class="token punctuation">,</span><span class="token char">'y'</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#123;</span> <span class="token char">'A'</span><span class="token punctuation">,</span><span class="token char">'u'</span><span class="token punctuation">,</span><span class="token char">'g'</span><span class="token punctuation">,</span><span class="token char">'u'</span><span class="token punctuation">,</span><span class="token char">'s'</span><span class="token punctuation">,</span><span class="token char">'t'</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#123;</span> <span class="token char">'S'</span><span class="token punctuation">,</span><span class="token char">'e'</span><span class="token punctuation">,</span><span class="token char">'p'</span><span class="token punctuation">,</span><span class="token char">'t'</span><span class="token punctuation">,</span><span class="token char">'e'</span><span class="token punctuation">,</span><span class="token char">'m'</span><span class="token punctuation">,</span><span class="token char">'b'</span><span class="token punctuation">,</span><span class="token char">'e'</span><span class="token punctuation">,</span><span class="token char">'r'</span><span class="token punctuation">,</span>  <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#123;</span> <span class="token char">'O'</span><span class="token punctuation">,</span><span class="token char">'c'</span><span class="token punctuation">,</span><span class="token char">'t'</span><span class="token punctuation">,</span><span class="token char">'o'</span><span class="token punctuation">,</span><span class="token char">'b'</span><span class="token punctuation">,</span><span class="token char">'e'</span><span class="token punctuation">,</span><span class="token char">'r'</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#123;</span> <span class="token char">'N'</span><span class="token punctuation">,</span><span class="token char">'o'</span><span class="token punctuation">,</span><span class="token char">'v'</span><span class="token punctuation">,</span><span class="token char">'e'</span><span class="token punctuation">,</span><span class="token char">'m'</span><span class="token punctuation">,</span><span class="token char">'b'</span><span class="token punctuation">,</span><span class="token char">'e'</span><span class="token punctuation">,</span><span class="token char">'r'</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#123;</span> <span class="token char">'D'</span><span class="token punctuation">,</span><span class="token char">'e'</span><span class="token punctuation">,</span><span class="token char">'c'</span><span class="token punctuation">,</span><span class="token char">'e'</span><span class="token punctuation">,</span><span class="token char">'m'</span><span class="token punctuation">,</span><span class="token char">'b'</span><span class="token punctuation">,</span><span class="token char">'e'</span><span class="token punctuation">,</span><span class="token char">'r'</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span> <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// in 0..11 range</span>
<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">get_month2</span> <span class="token punctuation">(</span><span class="token keyword">int</span> month<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token operator">&amp;</span>month2<span class="token punctuation">[</span>month<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Optimizing msvs</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">month2  DB      04aH
        DB      061H
        DB      06eH
        DB      075H
        DB      061H
        DB      072H
        DB      079H
        DB      00H
        DB      00H
        DB      00H
...
get_month2 PROC
; sign-extend input argument and promote to 64-bit value
        movsxd  rax, ecx
        lea     rcx, QWORD PTR [rax+rax*4]
; RCX&#x3D;month+month*4&#x3D;month*5
        lea     rax, OFFSET FLAT:month2
; RAX&#x3D;pointer to table
        lea     rax, QWORD PTR [rax+rcx*2]
; RAX&#x3D;pointer to table + RCX*2&#x3D;pointer to table + month*5*2&#x3D;pointer to table + month*10
        ret     0
get_month2  ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>
<p>上述程序完全不访问内存。整个函数的功能，只是计算月份名称字符串的首字母指针pointer_to_the_table+month*10。它使用单条LEA指令，替代了多条MUL和MOV指令。</p>
</li>
<li>
<p>上述数组的每个字符串都占用10字节空间。最长的字符串由“September”和内容为零的字节构成，其余的字符串使用零字节对齐，所以每个字符串都占用10个字节。如此一来，计算字符串首地址的方式变得简单，整个函数的效率也会有所提高。</p>
</li>
</ul>
<hr />
<p><code>Optimizing gcc</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">movsx   rdi, edi
    lea     rax, [rdi+rdi*4]
    lea     rax, month2[rax+rax]
    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>直接使用LEA指令进行乘以10的计算</p>
<hr />
<p><code>Not Optimizing GCC</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">get_month2:
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-4], edi
        mov     eax, DWORD PTR [rbp-4]
        movsx   rdx, eax
; RDX &#x3D; sign-extended input value
        mov     rax, rdx
; RAX &#x3D; month
        sal     rax, 2
; RAX &#x3D; month&lt;&lt;2 &#x3D; month*4
        add     rax, rdx
; RAX &#x3D; RAX+RDX &#x3D; month*4+month &#x3D; month*5
        add     rax, rax
; RAX &#x3D; RAX*2 &#x3D; month*5*2 &#x3D; month*10
        add     rax, OFFSET FLAT:month2
; RAX &#x3D; month*10 + pointer to the table
        pop     rbp
        ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不开启优化编译，GCC的乘法运算方式不同</p>
<hr />
<p><code>Not Optimizing MSVS</code></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">month$ &#x3D; 8
get_month2 PROC
        mov      DWORD PTR [rsp+8], ecx
        movsxd   rax, DWORD PTR month$[rsp]
; RAX &#x3D; sign-extended input value into 64-bit one
        imul     rax, rax, 10
; RAX &#x3D; RAX*10
        lea      rcx, OFFSET FLAT:month2
; RCX &#x3D; pointer to the table
        add      rcx, rax
; RCX &#x3D; RCX+RAX &#x3D; pointer to the table+month*10
        mov      rax, rcx
; RAX &#x3D; pointer to the table+month*10
        mov      ecx, 1
; RCX &#x3D; 1
        imul     rcx, rcx, 0
; RCX &#x3D; 1*0 &#x3D; 0
        add      rax, rcx
; RAX &#x3D; pointer to the table+month*10 + 0 &#x3D; pointer to the table+month*10
        ret      0
get_month2 ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>msvs不开启优化，会直接使用imul指令，然而为什么RCX要乘以0？作者说这是MSVS的怪癖代码，希望我们从编程人员的角度来理解程序的源代码</li>
</ul>
<h3 id="problem-4"><a class="markdownIt-Anchor" href="#problem-4"></a> Problem</h3>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; 函数开始
?s@@YAXPAN00@Z PROC; s, COMDAT

; 将参数加载到寄存器中
    mov    eax, DWORD PTR _b$[esp-4]  ; eax &#x3D; 结束地址 - 4 (实际是_b的地址)
    mov    ecx, DWORD PTR _a$[esp-4]  ; ecx &#x3D; 起始地址 - 4(a的地址)
    mov    edx, DWORD PTR _c$[esp-4]  ; edx &#x3D; 结果存放地址 - 4(c的地址)

; 保存寄存器edi和esi，用于循环,因为此后edi和esi作为计数器,
    push   esi  
    push   edi
    
; 计算数组长度，两次减法实质上得到的是_b - _a的值，即元素个数，但这里是用字节数表示的
    sub    ecx, eax                  ; ecx &#x3D; 起始地址与结束地址之间的距离（字节数）
    sub    edx, eax                  ; edx同样调整，确保结果存回原区间

; 设置外层循环次数为200次（每次处理两个浮点数，合计处理400个浮点数）
    mov    edi, 200     ; 000000c8H;edi&#x3D;i

$LL6@s:                              ; 外层循环开始
    push   100          ; 00000064H   ; 内层循环计数器，每次处理100对浮点数
    pop	esi;esi&#x3D;100,作为计数器
$LL3@s:                              ; 内层循环开始
    fld    QWORD PTR [ecx+eax]      ; 将当前地址的浮点数推入FPU堆栈
    fadd   QWORD PTR [eax]          ; 将源地址的浮点数与栈顶的浮点数相加
    fstp   QWORD PTR [edx+eax]      ; 将结果从堆栈弹出并存回目的地址
    add    eax, 8                   ; eax指针向前移动8字节，指向下一个浮点数
    dec    esi                      ; 内层循环计数器递减
    jne    SHORT $LL3@s              ; 如果未达到内层循环次数，则跳转继续内层循环

    dec    edi                      ; 外层循环计数器递减
    jne    SHORT $LL6@s              ; 如果未达到外层循环次数，则跳转继续外层循环

; 恢复保存的寄存器，并清理栈
    pop    edi
    pop    esi
    ret    0                        ; 函数返回，不带返回值
?s@@YAXPAN00@Z  ENDP   ; s 函数结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">M</span>    <span class="token expression"><span class="token number">100</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span>    <span class="token expression"><span class="token number">200</span></span></span>
<span class="token keyword">void</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token keyword">double</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">double</span> <span class="token operator">*</span>b<span class="token punctuation">,</span> <span class="token keyword">double</span> <span class="token operator">*</span>c<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>M<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
      <span class="token operator">*</span><span class="token punctuation">(</span>c<span class="token operator">+</span>i<span class="token operator">*</span>M<span class="token operator">+</span>j<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span>a<span class="token operator">+</span>i<span class="token operator">*</span>M<span class="token operator">+</span>j<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token operator">*</span><span class="token punctuation">(</span>b<span class="token operator">+</span>i<span class="token operator">*</span>M<span class="token operator">+</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr />
<ol start="2">
<li></li>
</ol>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; 函数开始，标准的函数框架建立
?m@@YAXPAN00@Z PROC; m, COMDAT
    push   ebp
    mov    ebp, esp
    push   ecx                     ; 保存ecx
    push   ecx                     ; 这里重复push ecx可能是为了对齐栈或者保留空间(MSVS的怪癖代码)
    mov    edx, DWORD PTR _a$[ebp] ; edx &#x3D; _a$ (起始地址)
    push   ebx                     ; 保存ebx
    mov    ebx, DWORD PTR _c$[ebp] ; ebx &#x3D; _c$ (目标地址或另一个起始地址)
    push   esi                     ; 保存esi
    mov    esi, DWORD PTR _b$[ebp] ; esi &#x3D; _b$ (可能的结束地址或偏移量)

; 计算数组长度或偏移
    sub    edx, esi                ; 计算长度或偏移1;edx&#x3D;edx-esi&#x3D;ptr(a-b)
    push   edi                     ; 保存edi
    sub    esi, ebx                ; 计算长度或偏移2，注意这里的操作似乎与预期逻辑不符，需结合具体算法理解
;esi&#x3D;esi-ebx&#x3D;ptr(b-c)
; 初始化循环计数器
    mov    DWORD PTR tv315[ebp], 100  ; 外层循环计数器设为100;tv315&#x3D;100
$LL9@m:                              ; 外层循环开始
    mov    eax, ebx                ; eax &#x3D; ebx&#x3D;c，可能用于地址计算
    mov    DWORD PTR tv291[ebp], 300  ; 内层循环计数器设为300;tv291&#x3D;300
$LL6@m:                              ; 内层循环开始
    fldz                           ; 加载0.0到FPU堆栈，准备累加
    lea    ecx, DWORD PTR [esi+eax] ; 计算当前处理元素的地址;ecx&#x3D;b
    fstp   QWORD PTR [eax]         ; 将0.0存入eax指向的位置，清0,此时eax指向c;*c&#x3D;0位于第二层循环，eax作为循环的指针

    mov    edi, 200                ; edi作为计数器;edi&#x3D;200
$LL3@m:                              ; 第三层循环开始
    dec    edi                     ; 循环计数器递减
    fld    QWORD PTR [ecx+edx]     ; 从当前地址加上之前计算的偏移处取元素，推入FPU栈;ecx+edx&#x3D;b+a-b&#x3D;a
    fmul   QWORD PTR [ecx]         ; 将栈顶元素与ecx地址处的元素相乘 *a&#x3D;*ax*b+c
    fadd   QWORD PTR [eax]         ; 将乘积与eax地址处的元素相加，并将结果放回eax地址,c
    fstp   QWORD PTR [eax]         ; 弹出FPU栈顶元素（已无用）;这里的运算与edi无关
    jne    SHORT $LL3@m             ; 若edi非零，继续内层循环

    add    eax, 8                  ; eax指向下一个元素
    dec    DWORD PTR tv291[ebp]     ; 内层循环计数器递减
    jne    SHORT $LL6@m             ; 若内层计数器非零，继续内层循环

    add    ebx, 800                ; ebx增加800，可能用于处理下一批数据
    dec    DWORD PTR tv315[ebp]     ; 外层循环计数器递减
    jne    SHORT $LL9@m             ; 若外层计数器非零，继续外层循环

; 清理并返回
    pop    edi
    pop    esi
    pop    ebx
    leave                          ; 恢复ebp和esp
    ret    0                       ; 函数返回
?m@@YAXPAN00@Z ENDP                   ; m函数结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> tv315 <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">for</span> tv291 <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token operator">*</span><span class="token punctuation">(</span>c<span class="token operator">+</span>tv315<span class="token operator">*</span><span class="token number">100</span><span class="token operator">+</span>tv291<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">for</span> edi <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token operator">*</span><span class="token punctuation">(</span>c<span class="token operator">+</span>tv315<span class="token operator">*</span><span class="token number">100</span><span class="token operator">+</span>tv291<span class="token punctuation">)</span><span class="token operator">+=</span><span class="token operator">*</span><span class="token punctuation">(</span>a<span class="token operator">+</span>tv315<span class="token operator">*</span><span class="token number">100</span><span class="token operator">+</span>tv291<span class="token punctuation">)</span><span class="token operator">*</span> <span class="token operator">*</span><span class="token punctuation">(</span>b<span class="token operator">+</span>tv315<span class="token operator">*</span><span class="token number">100</span><span class="token operator">+</span>tv291<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="3">
<li></li>
</ol>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">_array$ &#x3D; 8
_x$ &#x3D; 12
_y$ &#x3D; 16
_f      PROC
        mov     eax, DWORD PTR _x$[esp-4];eax&#x3D;x;
        mov     edx, DWORD PTR _y$[esp-4];edx&#x3D;y;
        mov     ecx, eax;ecx&#x3D;x;
        shl     ecx, 4;x*2^4;
        sub     ecx, eax;ecx&#x3D;15x
        lea     eax, DWORD PTR [edx+ecx*8];eax&#x3D;y+120x
        mov     ecx, DWORD PTR _array$[esp-4];ecx&#x3D;8
        fld     QWORD PTR [ecx+eax*8]
        ret     0
_f      ENDP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">double</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">double</span> array<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">120</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
         <span class="token keyword">return</span> array<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</div></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2024/05/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="prev" title="数据结构复习笔记"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">数据结构复习笔记</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2024/05/09/PwnCollege2-ProgramInteraction/" rel="next" title="pwnCollege1-ProgramMiuse"><span class="post-nav-text">pwnCollege1-ProgramMiuse</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>您需要科学上网，才可使用评论区功能。</span><br></div><div id="waline"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@waline/client@v2/dist/waline.css"><script>window.CONFIG.waline.config.path = "/2024/05/23/re4b%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"</script><div class="js-Pjax"><script src="/js/comments/waline.js" type="module" defer></script></div></div></main><footer class="sidebar-translate" id="footer"><div class="beian"><a rel="noopener" href="https://beian.miit.gov.cn/" target="_blank"></a></div><div class="copyright"><span>&copy; 2022 – 2024 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> Npc</span></div><div class="footer-custom-text">=w=</div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="Search"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:search-line"></span></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="https://fastly.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js"></script><script src="/js/search/local-search.js" defer type="module"></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><span class="icon iconify" data-icon="ri:close-line"></span></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="Searching..." value=""></div><div class="search-result-container"></div></div></body></html>